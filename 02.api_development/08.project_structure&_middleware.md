# Project Structure & Middleware: Building Scalable Go Applications

## Table of Contents
1. [Why Project Structure Matters](#why-project-structure-matters)
2. [Evolution from Simple to Complex](#evolution-from-simple-to-complex)
3. [Standard Go Project Layouts](#standard-go-project-layouts)
4. [Understanding Separation of Concerns](#understanding-separation-of-concerns)
5. [Handlers, Models, and Services](#handlers-models-and-services)
6. [Understanding Middleware](#understanding-middleware)
7. [Implementing Common Middleware](#implementing-common-middleware)
8. [Middleware Chains and Order](#middleware-chains-and-order)
9. [Complete Project Example](#complete-project-example)
10. [Best Practices and Patterns](#best-practices-and-patterns)

---

## Why Project Structure Matters

### The Problem with Unorganized Code

```go
// What happens when everything is in one file (main.go):

package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "strings"
    "time"
)

// User struct mixed with everything else
type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email"`
    Password string `json:"-"`
}

// Global variables everywhere
var users []User
var nextID = 1

// Business logic mixed with HTTP handling
func createUserHandler(w http.ResponseWriter, r *http.Request) {
    // Parsing request
    var user User
    json.NewDecoder(r.Body).Decode(&user)
    
    // Validation logic
    if user.Name == "" || user.Email == "" {
        http.Error(w, "Invalid input", 400)
        return
    }
    
    // Business logic
    user.ID = nextID
    nextID++
    users = append(users, user)
    
    // Response formatting
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// Authentication logic mixed with handlers
func adminHandler(w http.ResponseWriter, r *http.Request) {
    // Auth logic repeated everywhere
    token := r.Header.Get("Authorization")
    if token != "Bearer admin-token" {
        http.Error(w, "Unauthorized", 401)
        return
    }
    
    // Logging logic repeated
    log.Printf("Admin access: %s %s", r.Method, r.URL.Path)
    
    // Actual handler logic
    fmt.Fprintf(w, "Admin panel")
}

func main() {
    // Everything mixed together - hard to test, maintain, or scale
    http.HandleFunc("/users", createUserHandler)
    http.HandleFunc("/admin", adminHandler)
    http.ListenAndServe(":8080", nil)
}

// Problems with this approach:
// 1. Hard to test individual components
// 2. Code duplication (auth, logging repeated)
// 3. No clear separation of concerns
// 4. Difficult to add new features
// 5. Hard to understand for new developers
```

### Benefits of Good Structure

```go
// What we want to achieve:

// Clear separation of concerns
// ├── handlers/     (HTTP layer)
// ├── services/     (Business logic)
// ├── models/       (Data structures)
// ├── middleware/   (Cross-cutting concerns)
// └── main.go       (Application entry point)

// Benefits:
// 1. Easy to test each component in isolation
// 2. Clear responsibilities for each package
// 3. Reusable middleware components
// 4. Easy to understand and maintain
// 5. Scales well as project grows
```

---

## Evolution from Simple to Complex

### Stage 1: Single File (Beginner)

```go
// main.go - Everything in one place
package main

import (
    "fmt"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello, World!")
    })
    
    http.ListenAndServe(":8080", nil)
}

// Good for: Learning, prototypes, very simple applications
// Problems: Not scalable, hard to test
```

### Stage 2: Multiple Files, Same Package

```go
// main.go
package main

func main() {
    setupRoutes()
    http.ListenAndServe(":8080", nil)
}

// handlers.go
package main

import (
    "fmt"
    "net/http"
)

func setupRoutes() {
    http.HandleFunc("/users", usersHandler)
    http.HandleFunc("/posts", postsHandler)
}

func usersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Users endpoint")
}

func postsHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Posts endpoint")
}

// models.go
package main

type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

type Post struct {
    ID     int    `json:"id"`
    Title  string `json:"title"`
    UserID int    `json:"user_id"`
}

// Good for: Small to medium applications
// Problems: Still everything in main package, no clear boundaries
```

### Stage 3: Proper Package Structure

```go
// Project structure:
// myapp/
// ├── main.go
// ├── handlers/
// │   ├── users.go
// │   └── posts.go
// ├── models/
// │   ├── user.go
// │   └── post.go
// └── services/
//     ├── user_service.go
//     └── post_service.go

// main.go
package main

import (
    "myapp/handlers"
    "net/http"
)

func main() {
    http.HandleFunc("/users", handlers.UsersHandler)
    http.HandleFunc("/posts", handlers.PostsHandler)
    http.ListenAndServe(":8080", nil)
}

// Good for: Most applications
// Benefits: Clear separation, reusable, testable
```

---

## Standard Go Project Layouts

### Basic Web API Structure

```
myapi/
├── main.go                 # Application entry point
├── go.mod                  # Go modules file
├── go.sum                  # Dependencies checksum
├── README.md               # Project documentation
├── .env                    # Environment variables
├── config/                 # Configuration
│   └── config.go
├── models/                 # Data structures
│   ├── user.go
│   ├── post.go
│   └── response.go
├── handlers/               # HTTP handlers
│   ├── users.go
│   ├── posts.go
│   └── health.go
├── services/               # Business logic
│   ├── user_service.go
│   └── post_service.go
├── middleware/             # Middleware functions
│   ├── auth.go
│   ├── logging.go
│   └── cors.go
├── database/               # Database related
│   ├── connection.go
│   └── migrations/
└── tests/                  # Test files
    ├── handlers_test.go
    └── services_test.go
```

### Advanced Project Structure

```
enterprise-api/
├── cmd/                    # Application entry points
│   ├── api/
│   │   └── main.go         # API server
│   ├── worker/
│   │   └── main.go         # Background worker
│   └── migrate/
│       └── main.go         # Database migrations
├── internal/               # Private application code
│   ├── api/
│   │   ├── handlers/       # HTTP handlers
│   │   ├── middleware/     # HTTP middleware
│   │   └── routes.go       # Route definitions
│   ├── services/           # Business logic
│   ├── repository/         # Data access layer
│   ├── models/             # Domain models
│   └── config/             # Configuration
├── pkg/                    # Public library code
│   ├── logger/
│   ├── validator/
│   └── utils/
├── deployments/            # Deployment configurations
│   ├── docker/
│   └── kubernetes/
├── docs/                   # Documentation
└── scripts/                # Build and deployment scripts
```

---

## Understanding Separation of Concerns

### What is Separation of Concerns?

```go
// Separation of Concerns = Each part of code has ONE responsibility

// ❌ BAD: Everything mixed together
func badUserHandler(w http.ResponseWriter, r *http.Request) {
    // 1. Parsing HTTP request
    var user User
    json.NewDecoder(r.Body).Decode(&user)
    
    // 2. Validation
    if user.Name == "" { /* ... */ }
    
    // 3. Database operations
    db.Exec("INSERT INTO users...", user.Name, user.Email)
    
    // 4. Business logic
    sendWelcomeEmail(user.Email)
    
    // 5. HTTP response formatting
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}

// ✅ GOOD: Each component has one responsibility
func goodUserHandler(w http.ResponseWriter, r *http.Request) {
    // Handler only handles HTTP concerns
    var request CreateUserRequest
    if err := parseRequest(r, &request); err != nil {
        sendError(w, err, http.StatusBadRequest)
        return
    }
    
    // Delegate business logic to service
    user, err := userService.CreateUser(request)
    if err != nil {
        sendError(w, err, http.StatusInternalServerError)
        return
    }
    
    // Handler only handles HTTP response
    sendJSON(w, user, http.StatusCreated)
}
```

### The Layers Explained

```go
// 1. HANDLERS (HTTP Layer)
// Responsibility: Handle HTTP requests and responses
// - Parse HTTP requests
// - Validate request format
// - Call appropriate service
// - Format HTTP responses
// - Handle HTTP status codes

// 2. SERVICES (Business Logic Layer)
// Responsibility: Implement business rules
// - Validate business rules
// - Coordinate between different components
// - Implement application logic
// - Handle transactions

// 3. MODELS (Data Layer)
// Responsibility: Define data structures
// - Data structures/entities
// - Data validation rules
// - Serialization/deserialization

// 4. REPOSITORY (Data Access Layer)
// Responsibility: Data persistence
// - Database operations
// - Data mapping
// - Query optimization

// 5. MIDDLEWARE (Cross-cutting Layer)
// Responsibility: Common functionality across requests
// - Authentication
// - Logging
// - CORS
// - Rate limiting
```

---

## Handlers, Models, and Services

### Models: Data Structures

```go
// models/user.go
package models

import (
    "errors"
    "time"
    "regexp"
)

type User struct {
    ID        int       `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Email     string    `json:"email" db:"email"`
    Password  string    `json:"-" db:"password"`        // Never serialize to JSON
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// Validation methods on the model
func (u *User) Validate() error {
    if u.Name == "" {
        return errors.New("name is required")
    }
    
    if len(u.Name) < 2 {
        return errors.New("name must be at least 2 characters")
    }
    
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(u.Email) {
        return errors.New("invalid email format")
    }
    
    return nil
}

// models/request.go
package models

type CreateUserRequest struct {
    Name     string `json:"name"`
    Email    string `json:"email"`
    Password string `json:"password"`
}

type UpdateUserRequest struct {
    Name  *string `json:"name,omitempty"`   // Pointer = optional field
    Email *string `json:"email,omitempty"`
}

// models/response.go
package models

type APIResponse struct {
    Success bool        `json:"success"`
    Message string      `json:"message,omitempty"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}

type PaginatedResponse struct {
    APIResponse
    Page       int `json:"page"`
    PerPage    int `json:"per_page"`
    TotalPages int `json:"total_pages"`
    TotalItems int `json:"total_items"`
}
```

### Services: Business Logic

```go
// services/user_service.go
package services

import (
    "errors"
    "myapp/models"
    "myapp/repository"
    "golang.org/x/crypto/bcrypt"
)

type UserService struct {
    userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) *UserService {
    return &UserService{
        userRepo: userRepo,
    }
}

func (s *UserService) CreateUser(req models.CreateUserRequest) (*models.User, error) {
    // 1. Create user model from request
    user := &models.User{
        Name:  req.Name,
        Email: req.Email,
    }
    
    // 2. Validate business rules
    if err := user.Validate(); err != nil {
        return nil, err
    }
    
    // 3. Check if user already exists
    existingUser, _ := s.userRepo.GetByEmail(req.Email)
    if existingUser != nil {
        return nil, errors.New("user with this email already exists")
    }
    
    // 4. Hash password
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    user.Password = string(hashedPassword)
    
    // 5. Save to database
    createdUser, err := s.userRepo.Create(user)
    if err != nil {
        return nil, err
    }
    
    // 6. Additional business logic (send welcome email, etc.)
    s.sendWelcomeEmail(createdUser.Email)
    
    return createdUser, nil
}

func (s *UserService) GetUser(id int) (*models.User, error) {
    user, err := s.userRepo.GetByID(id)
    if err != nil {
        return nil, err
    }
    
    if user == nil {
        return nil, errors.New("user not found")
    }
    
    return user, nil
}

func (s *UserService) UpdateUser(id int, req models.UpdateUserRequest) (*models.User, error) {
    // Get existing user
    user, err := s.GetUser(id)
    if err != nil {
        return nil, err
    }
    
    // Update only provided fields
    if req.Name != nil {
        user.Name = *req.Name
    }
    if req.Email != nil {
        user.Email = *req.Email
    }
    
    // Validate updated user
    if err := user.Validate(); err != nil {
        return nil, err
    }
    
    // Save changes
    return s.userRepo.Update(user)
}

func (s *UserService) DeleteUser(id int) error {
    // Check if user exists
    _, err := s.GetUser(id)
    if err != nil {
        return err
    }
    
    // Perform deletion
    return s.userRepo.Delete(id)
}

func (s *UserService) sendWelcomeEmail(email string) {
    // This would integrate with email service
    // For now, just log
    log.Printf("Sending welcome email to %s", email)
}
```

### Handlers: HTTP Layer

```go
// handlers/users.go
package handlers

import (
    "encoding/json"
    "net/http"
    "strconv"
    "strings"
    
    "myapp/models"
    "myapp/services"
)

type UserHandler struct {
    userService *services.UserService
}

func NewUserHandler(userService *services.UserService) *UserHandler {
    return &UserHandler{
        userService: userService,
    }
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    // 1. Parse request
    var req models.CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, "Invalid JSON format", http.StatusBadRequest)
        return
    }
    
    // 2. Call service (business logic)
    user, err := h.userService.CreateUser(req)
    if err != nil {
        h.sendError(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // 3. Send response
    h.sendJSON(w, models.APIResponse{
        Success: true,
        Message: "User created successfully",
        Data:    user,
    }, http.StatusCreated)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    // 1. Extract ID from URL
    idStr := strings.TrimPrefix(r.URL.Path, "/users/")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.sendError(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    // 2. Call service
    user, err := h.userService.GetUser(id)
    if err != nil {
        if err.Error() == "user not found" {
            h.sendError(w, err.Error(), http.StatusNotFound)
        } else {
            h.sendError(w, err.Error(), http.StatusInternalServerError)
        }
        return
    }
    
    // 3. Send response
    h.sendJSON(w, models.APIResponse{
        Success: true,
        Data:    user,
    }, http.StatusOK)
}

func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request) {
    // Extract ID
    idStr := strings.TrimPrefix(r.URL.Path, "/users/")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.sendError(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    // Parse request
    var req models.UpdateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, "Invalid JSON format", http.StatusBadRequest)
        return
    }
    
    // Call service
    user, err := h.userService.UpdateUser(id, req)
    if err != nil {
        h.sendError(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // Send response
    h.sendJSON(w, models.APIResponse{
        Success: true,
        Message: "User updated successfully",
        Data:    user,
    }, http.StatusOK)
}

func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) {
    // Extract ID
    idStr := strings.TrimPrefix(r.URL.Path, "/users/")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        h.sendError(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    // Call service
    if err := h.userService.DeleteUser(id); err != nil {
        h.sendError(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // Send response
    h.sendJSON(w, models.APIResponse{
        Success: true,
        Message: "User deleted successfully",
    }, http.StatusOK)
}

// Helper methods for consistent responses
func (h *UserHandler) sendJSON(w http.ResponseWriter, data interface{}, statusCode int) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(data)
}

func (h *UserHandler) sendError(w http.ResponseWriter, message string, statusCode int) {
    h.sendJSON(w, models.APIResponse{
        Success: false,
        Error:   message,
    }, statusCode)
}
```

---

## Understanding Middleware

### What is Middleware?

Middleware is code that runs **before** and/or **after** your main handler:

```go
// Think of middleware like layers of an onion:
// Request → Middleware 1 → Middleware 2 → Handler → Middleware 2 → Middleware 1 → Response

func conceptualMiddleware() {
    // Without middleware - repetitive code:
    func handler1(w http.ResponseWriter, r *http.Request) {
        log.Printf("Request: %s %s", r.Method, r.URL.Path) // Logging
        
        if !isAuthenticated(r) { // Authentication
            http.Error(w, "Unauthorized", 401)
            return
        }
        
        // Actual handler logic
        fmt.Fprintf(w, "Handler 1")
    }
    
    func handler2(w http.ResponseWriter, r *http.Request) {
        log.Printf("Request: %s %s", r.Method, r.URL.Path) // Same logging code
        
        if !isAuthenticated(r) { // Same auth code
            http.Error(w, "Unauthorized", 401)
            return
        }
        
        // Actual handler logic
        fmt.Fprintf(w, "Handler 2")
    }
    
    // With middleware - DRY (Don't Repeat Yourself):
    func withMiddleware() {
        handler := applyMiddleware(actualHandler, 
            LoggingMiddleware,      // Runs first
            AuthenticationMiddleware, // Runs second
        )
        
        http.HandleFunc("/endpoint", handler)
    }
}
```

### Middleware Pattern in Go

```go
// Middleware signature: takes a handler, returns a handler
type Middleware func(http.Handler) http.Handler

// Basic middleware structure
func ExampleMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Code before handler (preprocessing)
        fmt.Println("Before handler")
        
        // Call the next handler in the chain
        next.ServeHTTP(w, r)
        
        // Code after handler (postprocessing)
        fmt.Println("After handler")
    })
}

// How middleware chains work:
func middlewareChainExample() {
    // Request flow:
    // 1. Request comes in
    // 2. Middleware A starts
    // 3. Middleware B starts
    // 4. Handler executes
    // 5. Middleware B ends
    // 6. Middleware A ends
    // 7. Response sent
    
    finalHandler := func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Final handler")
    }
    
    // Apply middleware in reverse order (last applied runs first)
    withMiddleware := MiddlewareA(MiddlewareB(http.HandlerFunc(finalHandler)))
    
    http.Handle("/example", withMiddleware)
}
```

---

## Implementing Common Middleware

### Logging Middleware

```go
// middleware/logging.go
package middleware

import (
    "log"
    "net/http"
    "time"
)

// Simple logging middleware
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Log request start
        log.Printf("Started %s %s", r.Method, r.URL.Path)
        
        // Call next handler
        next.ServeHTTP(w, r)
        
        // Log request completion
        duration := time.Since(start)
        log.Printf("Completed %s %s in %v", r.Method, r.URL.Path, duration)
    })
}

// Advanced logging middleware with response status
func AdvancedLoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Create a wrapper to capture response status
        wrapper := &responseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK, // Default status
        }
        
        // Call next handler with wrapper
        next.ServeHTTP(wrapper, r)
        
        // Log with status code and duration
        duration := time.Since(start)
        log.Printf("%s %s - %d - %v - %s", 
            r.Method, 
            r.URL.Path, 
            wrapper.statusCode,
            duration,
            r.UserAgent(),
        )
    })
}

// Response writer wrapper to capture status code
type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

### Authentication Middleware

```go
// middleware/auth.go
package middleware

import (
    "context"
    "encoding/json"
    "net/http"
    "strings"
)

type AuthMiddleware struct {
    secretKey string
}

func NewAuthMiddleware(secretKey string) *AuthMiddleware {
    return &AuthMiddleware{
        secretKey: secretKey,
    }
}

func (am *AuthMiddleware) RequireAuth(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Get authorization header
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" {
            am.sendUnauthorized(w, "Missing authorization header")
            return
        }
        
        // Check Bearer token format
        if !strings.HasPrefix(authHeader, "Bearer ") {
            am.sendUnauthorized(w, "Invalid authorization format")
            return
        }
        
        // Extract token
        token := strings.TrimPrefix(authHeader, "Bearer ")
        
        // Validate token (simplified - in real app, use JWT)
        userID, err := am.validateToken(token)
        if err != nil {
            am.sendUnauthorized(w, "Invalid token")
            return
        }
        
        // Add user info to context
        ctx := context.WithValue(r.Context(), "userID", userID)
        r = r.WithContext(ctx)
        
        // Continue to next handler
        next.ServeHTTP(w, r)
    })
}

func (am *AuthMiddleware) RequireAdmin(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // First check authentication
        am.RequireAuth(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Get user from context
            userID := r.Context().Value("userID").(int)
            
            // Check if user is admin (simplified)
            if !am.isAdmin(userID) {
                am.sendForbidden(w, "Admin access required")
                return
            }
            
            // Continue to next handler
            next.ServeHTTP(w, r)
        })).ServeHTTP(w, r)
    })
}

func (am *AuthMiddleware) validateToken(token string) (int, error) {
    // Simplified token validation
    // In real application, use JWT or database lookup
    validTokens := map[string]int{
        "user-token-123":  1,
        "admin-token-456": 2,
    }
    
    if userID, exists := validTokens[token]; exists {
        return userID, nil
    }
    
    return 0, errors.New("invalid token")
}

func (am *AuthMiddleware) isAdmin(userID int) bool {
    // Simplified admin check
    // In real application, check database
    adminUsers := []int{2} // User ID 2 is admin
    
    for _, adminID := range adminUsers {
        if adminID == userID {
            return true
        }
    }
    return false
}

func (am *AuthMiddleware) sendUnauthorized(w http.ResponseWriter, message string) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusUnauthorized)
    json.NewEncoder(w).Encode(map[string]string{
        "error": message,
    })
}

func (am *AuthMiddleware) sendForbidden(w http.ResponseWriter, message string) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusForbidden)
    json.NewEncoder(w).Encode(map[string]string{
        "error": message,
    })
}
```

### CORS Middleware

```go
// middleware/cors.go
package middleware

import "net/http"

type CORSConfig struct {
    AllowedOrigins   []string
    AllowedMethods   []string
    AllowedHeaders   []string
    AllowCredentials bool
}

func DefaultCORSConfig() CORSConfig {
    return CORSConfig{
        AllowedOrigins: []string{"*"},
        AllowedMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowedHeaders: []string{"Content-Type", "Authorization"},
        AllowCredentials: false,
    }
}

func CORSMiddleware(config CORSConfig) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Set CORS headers
            if len(config.AllowedOrigins) > 0 {
                if config.AllowedOrigins[0] == "*" {
                    w.Header().Set("Access-Control-Allow-Origin", "*")
                } else {
                    // Check if origin is allowed
                    origin := r.Header.Get("Origin")
                    for _, allowedOrigin := range config.AllowedOrigins {
                        if origin == allowedOrigin {
                            w.Header().Set("Access-Control-Allow-Origin", origin)
                            break
                        }
                    }
                }
            }
            
            if len(config.AllowedMethods) > 0 {
                w.Header().Set("Access-Control-Allow-Methods", 
                    strings.Join(config.AllowedMethods, ", "))
            }
            
            if len(config.AllowedHeaders) > 0 {
                w.Header().Set("Access-Control-Allow-Headers", 
                    strings.Join(config.AllowedHeaders, ", "))
            }
            
            if config.AllowCredentials {
                w.Header().Set("Access-Control-Allow-Credentials", "true")
            }
            
            // Handle preflight OPTIONS request
            if r.Method == "OPTIONS" {
                w.WriteHeader(http.StatusOK)
                return
            }
            
            // Continue to next handler
            next.ServeHTTP(w, r)
        })
    }
}

// Simple CORS middleware for development
func DevCORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}
```

### Rate Limiting Middleware

```go
// middleware/rate_limit.go
package middleware

import (
    "encoding/json"
    "net/http"
    "sync"
    "time"
)

type RateLimiter struct {
    visitors map[string]*visitor
    mutex    sync.RWMutex
    rate     int           // requests per minute
    burst    int           // burst capacity
    cleanup  time.Duration // cleanup interval
}

type visitor struct {
    tokens   int
    lastSeen time.Time
}

func NewRateLimiter(rate, burst int) *RateLimiter {
    rl := &RateLimiter{
        visitors: make(map[string]*visitor),
        rate:     rate,
        burst:    burst,
        cleanup:  time.Minute,
    }
    
    // Start cleanup routine
    go rl.cleanup()
    
    return rl
}

func (rl *RateLimiter) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Get client IP
        ip := rl.getIP(r)
        
        // Check rate limit
        if !rl.allow(ip) {
            w.Header().Set("Content-Type", "application/json")
            w.WriteHeader(http.StatusTooManyRequests)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Rate limit exceeded",
            })
            return
        }
        
        // Continue to next handler
        next.ServeHTTP(w, r)
    })
}

func (rl *RateLimiter) allow(ip string) bool {
    rl.mutex.Lock()
    defer rl.mutex.Unlock()
    
    v, exists := rl.visitors[ip]
    if !exists {
        // New visitor
        rl.visitors[ip] = &visitor{
            tokens:   rl.burst - 1, // Use one token
            lastSeen: time.Now(),
        }
        return true
    }
    
    // Calculate tokens to add based on time passed
    now := time.Now()
    elapsed := now.Sub(v.lastSeen)
    tokensToAdd := int(elapsed.Minutes()) * rl.rate
    
    v.tokens += tokensToAdd
    if v.tokens > rl.burst {
        v.tokens = rl.burst
    }
    
    v.lastSeen = now
    
    if v.tokens > 0 {
        v.tokens--
        return true
    }
    
    return false
}

func (rl *RateLimiter) getIP(r *http.Request) string {
    // Check X-Forwarded-For header first
    forwarded := r.Header.Get("X-Forwarded-For")
    if forwarded != "" {
        return strings.Split(forwarded, ",")[0]
    }
    
    // Check X-Real-IP header
    realIP := r.Header.Get("X-Real-IP")
    if realIP != "" {
        return realIP
    }
    
    // Use remote address
    return r.RemoteAddr
}

func (rl *RateLimiter) cleanup() {
    ticker := time.NewTicker(rl.cleanup)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            rl.mutex.Lock()
            now := time.Now()
            for ip, visitor := range rl.visitors {
                // Remove visitors not seen for 10 minutes
                if now.Sub(visitor.lastSeen) > 10*time.Minute {
                    delete(rl.visitors, ip)
                }
            }
            rl.mutex.Unlock()
        }
    }
}
```

---

## Middleware Chains and Order

### Understanding Middleware Order

```go
func middlewareOrderExample() {
    // Middleware execution order is VERY important
    
    // ❌ Wrong order
    wrongOrder := func() {
        handler := AuthMiddleware(LoggingMiddleware(actualHandler))
        // Problem: If auth fails, logging might not capture the attempt
    }
    
    // ✅ Correct order
    correctOrder := func() {
        handler := LoggingMiddleware(AuthMiddleware(actualHandler))
        // Logging captures everything, then auth is checked
    }
    
    // Complete middleware chain example:
    completeChain := func() {
        handler := 
            RecoveryMiddleware(      // 1. Catch panics (outermost)
                LoggingMiddleware(   // 2. Log all requests
                    CORSMiddleware(  // 3. Handle CORS
                        RateLimitMiddleware( // 4. Rate limiting
                            AuthMiddleware(   // 5. Authentication
                                actualHandler, // 6. Your handler (innermost)
                            ),
                        ),
                    ),
                ),
            )
        
        // Execution order:
        // Request → Recovery → Logging → CORS → RateLimit → Auth → Handler
        // Response ← Recovery ← Logging ← CORS ← RateLimit ← Auth ← Handler
    }
}
```

### Middleware Chain Builder

```go
// middleware/chain.go
package middleware

import "net/http"

type Chain struct {
    middlewares []func(http.Handler) http.Handler
}

func NewChain(middlewares ...func(http.Handler) http.Handler) *Chain {
    return &Chain{
        middlewares: middlewares,
    }
}

func (c *Chain) Then(handler http.Handler) http.Handler {
    // Apply middlewares in reverse order
    for i := len(c.middlewares) - 1; i >= 0; i-- {
        handler = c.middlewares[i](handler)
    }
    return handler
}

func (c *Chain) ThenFunc(handlerFunc http.HandlerFunc) http.Handler {
    return c.Then(handlerFunc)
}

func (c *Chain) Append(middlewares ...func(http.Handler) http.Handler) *Chain {
    return &Chain{
        middlewares: append(c.middlewares, middlewares...),
    }
}

// Usage example
func chainExample() {
    // Create base chain for all routes
    baseChain := NewChain(
        RecoveryMiddleware,
        LoggingMiddleware,
        CORSMiddleware(DefaultCORSConfig()),
    )
    
    // Public routes (no auth)
    publicChain := baseChain.Append(
        RateLimitMiddleware(100), // 100 requests per minute
    )
    
    // Protected routes (with auth)
    protectedChain := baseChain.Append(
        RateLimitMiddleware(200), // Higher limit for authenticated users
        AuthMiddleware,
    )
    
    // Admin routes (with admin auth)
    adminChain := baseChain.Append(
        RateLimitMiddleware(500), // Highest limit for admins
        AuthMiddleware,
        AdminMiddleware,
    )
    
    // Apply to routes
    http.Handle("/public", publicChain.ThenFunc(publicHandler))
    http.Handle("/protected", protectedChain.ThenFunc(protectedHandler))
    http.Handle("/admin", adminChain.ThenFunc(adminHandler))
}
```

---

## Complete Project Example

### Project Structure

```
userapi/
├── main.go
├── go.mod
├── config/
│   └── config.go
├── models/
│   ├── user.go
│   ├── request.go
│   └── response.go
├── services/
│   └── user_service.go
├── handlers/
│   ├── users.go
│   └── health.go
├── middleware/
│   ├── auth.go
│   ├── logging.go
│   ├── cors.go
│   └── chain.go
├── repository/
│   └── memory_repository.go
└── utils/
    └── response.go
```

### Main Application

```go
// main.go
package main

import (
    "fmt"
    "log"
    "net/http"
    
    "userapi/config"
    "userapi/handlers"
    "userapi/middleware"
    "userapi/repository"
    "userapi/services"
)

func main() {
    // Load configuration
    cfg := config.Load()
    
    // Initialize repository
    userRepo := repository.NewMemoryUserRepository()
    
    // Initialize services
    userService := services.NewUserService(userRepo)
    
    // Initialize handlers
    userHandler := handlers.NewUserHandler(userService)
    healthHandler := handlers.NewHealthHandler()
    
    // Initialize middleware
    authMiddleware := middleware.NewAuthMiddleware(cfg.JWTSecret)
    rateLimiter := middleware.NewRateLimiter(100, 10) // 100 req/min, burst 10
    
    // Create middleware chains
    baseChain := middleware.NewChain(
        middleware.RecoveryMiddleware,
        middleware.AdvancedLoggingMiddleware,
        middleware.DevCORSMiddleware,
    )
    
    publicChain := baseChain.Append(
        rateLimiter.Middleware,
    )
    
    protectedChain := baseChain.Append(
        rateLimiter.Middleware,
        authMiddleware.RequireAuth,
    )
    
    adminChain := baseChain.Append(
        rateLimiter.Middleware,
        authMiddleware.RequireAdmin,
    )
    
    // Setup routes
    setupRoutes(userHandler, healthHandler, publicChain, protectedChain, adminChain)
    
    // Start server
    fmt.Printf("Server starting on port %s\n", cfg.Port)
    log.Fatal(http.ListenAndServe(":"+cfg.Port, nil))
}

func setupRoutes(
    userHandler *handlers.UserHandler,
    healthHandler *handlers.HealthHandler,
    publicChain *middleware.Chain,
    protectedChain *middleware.Chain,
    adminChain *middleware.Chain,
) {
    // Public routes
    http.Handle("/health", publicChain.ThenFunc(healthHandler.HealthCheck))
    
    // User routes
    http.Handle("/users", publicChain.ThenFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case "GET":
            userHandler.ListUsers(w, r)
        case "POST":
            userHandler.CreateUser(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    }))
    
    // Protected user routes
    http.Handle("/users/", protectedChain.ThenFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case "GET":
            userHandler.GetUser(w, r)
        case "PUT":
            userHandler.UpdateUser(w, r)
        case "DELETE":
            userHandler.DeleteUser(w, r)
        default:
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        }
    }))
    
    // Admin routes
    http.Handle("/admin/users", adminChain.ThenFunc(userHandler.AdminListUsers))
}
```

### Configuration

```go
// config/config.go
package config

import (
    "os"
    "strconv"
)

type Config struct {
    Port      string
    JWTSecret string
    Debug     bool
}

func Load() *Config {
    return &Config{
        Port:      getEnv("PORT", "8080"),
        JWTSecret: getEnv("JWT_SECRET", "your-secret-key"),
        Debug:     getEnvBool("DEBUG", true),
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvBool(key string, defaultValue bool) bool {
    if value := os.Getenv(key); value != "" {
        if parsed, err := strconv.ParseBool(value); err == nil {
            return parsed
        }
    }
    return defaultValue
}
```

### Repository Layer

```go
// repository/memory_repository.go
package repository

import (
    "errors"
    "sync"
    "time"
    
    "userapi/models"
)

type UserRepository interface {
    Create(user *models.User) (*models.User, error)
    GetByID(id int) (*models.User, error)
    GetByEmail(email string) (*models.User, error)
    GetAll() ([]models.User, error)
    Update(user *models.User) (*models.User, error)
    Delete(id int) error
}

type MemoryUserRepository struct {
    users  map[int]*models.User
    nextID int
    mutex  sync.RWMutex
}

func NewMemoryUserRepository() UserRepository {
    return &MemoryUserRepository{
        users:  make(map[int]*models.User),
        nextID: 1,
    }
}

func (r *MemoryUserRepository) Create(user *models.User) (*models.User, error) {
    r.mutex.Lock()
    defer r.mutex.Unlock()
    
    user.ID = r.nextID
    user.CreatedAt = time.Now()
    user.UpdatedAt = time.Now()
    
    r.users[user.ID] = user
    r.nextID++
    
    return user, nil
}

func (r *MemoryUserRepository) GetByID(id int) (*models.User, error) {
    r.mutex.RLock()
    defer r.mutex.RUnlock()
    
    user, exists := r.users[id]
    if !exists {
        return nil, errors.New("user not found")
    }
    
    return user, nil
}

func (r *MemoryUserRepository) GetByEmail(email string) (*models.User, error) {
    r.mutex.RLock()
    defer r.mutex.RUnlock()
    
    for _, user := range r.users {
        if user.Email == email {
            return user, nil
        }
    }
    
    return nil, errors.New("user not found")
}

func (r *MemoryUserRepository) GetAll() ([]models.User, error) {
    r.mutex.RLock()
    defer r.mutex.RUnlock()
    
    users := make([]models.User, 0, len(r.users))
    for _, user := range r.users {
        users = append(users, *user)
    }
    
    return users, nil
}

func (r *MemoryUserRepository) Update(user *models.User) (*models.User, error) {
    r.mutex.Lock()
    defer r.mutex.Unlock()
    
    existing, exists := r.users[user.ID]
    if !exists {
        return nil, errors.New("user not found")
    }
    
    user.CreatedAt = existing.CreatedAt
    user.UpdatedAt = time.Now()
    r.users[user.ID] = user
    
    return user, nil
}

func (r *MemoryUserRepository) Delete(id int) error {
    r.mutex.Lock()
    defer r.mutex.Unlock()
    
    if _, exists := r.users[id]; !exists {
        return errors.New("user not found")
    }
    
    delete(r.users, id)
    return nil
}
```

---

## Best Practices and Patterns

### Directory Organization Rules

```go
// 1. Package naming conventions
package main       // Only for main.go files
package handlers   // Lowercase, descriptive
package userservice // CamelCase for multi-word packages

// 2. File naming conventions
user.go           // Single entity
user_service.go   // Multi-word with underscore
handlers.go       // Generic functionality
users_handler.go  // Specific handler

// 3. Import organization
import (
    // Standard library first
    "encoding/json"
    "net/http"
    
    // Third-party packages
    "github.com/gorilla/mux"
    
    // Local packages last
    "myapp/models"
    "myapp/services"
)
```

### Dependency Injection

```go
// Instead of global variables, inject dependencies

// ❌ Bad: Global variables
var userService *services.UserService

func userHandler(w http.ResponseWriter, r *http.Request) {
    // Uses global variable
    user, err := userService.GetUser(123)
}

// ✅ Good: Dependency injection
type UserHandler struct {
    userService services.UserService
}

func NewUserHandler(userService services.UserService) *UserHandler {
    return &UserHandler{
        userService: userService,
    }
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    // Uses injected dependency
    user, err := h.userService.GetUser(123)
}
```

### Error Handling Patterns

```go
// Consistent error handling across layers

// Service layer errors
type ServiceError struct {
    Code    int
    Message string
    Err     error
}

func (e *ServiceError) Error() string {
    return e.Message
}

// Handler error responses
func (h *UserHandler) handleError(w http.ResponseWriter, err error) {
    var statusCode int
    var message string
    
    switch e := err.(type) {
    case *ServiceError:
        statusCode = e.Code
        message = e.Message
    default:
        statusCode = http.StatusInternalServerError
        message = "Internal server error"
    }
    
    h.sendError(w, message, statusCode)
}
```

### Testing Structure

```go
// tests/handlers_test.go
package tests

import (
    "testing"
    "net/http/httptest"
    
    "myapp/handlers"
    "myapp/services"
    "myapp/repository"
)

func TestUserHandler_CreateUser(t *testing.T) {
    // Setup
    repo := repository.NewMemoryUserRepository()
    service := services.NewUserService(repo)
    handler := handlers.NewUserHandler(service)
    
    // Test
    req := httptest.NewRequest("POST", "/users", strings.NewReader(`{"name":"John","email":"john@example.com"}`))
    w := httptest.NewRecorder()
    
    handler.CreateUser(w, req)
    
    // Assert
    if w.Code != http.StatusCreated {
        t.Errorf("Expected status %d, got %d", http.StatusCreated, w.Code)
    }
}
```

## Key Takeaways

### Project Structure Benefits
1. **Separation of Concerns** - Each package has a single responsibility
2. **Testability** - Easy to test each component in isolation
3. **Maintainability** - Easy to find and modify code
4. **Scalability** - Structure supports growth
5. **Team Collaboration** - Clear boundaries for different developers

### Middleware Advantages
1. **DRY Principle** - Don't repeat common functionality
2. **Cross-cutting Concerns** - Handle logging, auth, CORS in one place
3. **Composability** - Mix and match middleware as needed
4. **Reusability** - Use same middleware across different routes
5. **Clean Handlers** - Handlers focus only on business logic

### Layer Responsibilities
1. **Handlers** - HTTP request/response handling
2. **Services** - Business logic and coordination
3. **Repository** - Data access and persistence
4. **Models** - Data structures and validation
5. **Middleware** - Cross-cutting concerns

### Best Practices
1. **Dependency Injection** - Avoid global variables
2. **Interface Usage** - Program to interfaces, not implementations
3. **Error Handling** - Consistent error patterns across layers
4. **Configuration** - Externalize configuration
5. **Testing** - Structure code to be easily testable

Good project structure and middleware are essential for building maintainable, scalable Go applications. They provide the foundation for clean, testable code that can grow with your needs!