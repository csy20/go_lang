# Advanced Routing: Beyond Standard Library Limitations

## Table of Contents
1. [Standard Library Router Limitations](#standard-library-router-limitations)
2. [What is Advanced Routing?](#what-is-advanced-routing)
3. [Understanding URL Parameters](#understanding-url-parameters)
4. [Introduction to Modern Routers](#introduction-to-modern-routers)
5. [Chi Router Deep Dive](#chi-router-deep-dive)
6. [Gorilla Mux Router](#gorilla-mux-router)
7. [Middleware Concepts](#middleware-concepts)
8. [Route Groups and Organization](#route-groups-and-organization)
9. [Real-World Routing Examples](#real-world-routing-examples)
10. [Performance and Best Practices](#performance-and-best-practices)

---

## Standard Library Router Limitations

### What Go's Standard Router Can Do

```go
// Standard library routing - basic pattern matching
func standardLibraryRouting() {
    // Exact matches
    http.HandleFunc("/", homeHandler)
    http.HandleFunc("/about", aboutHandler)
    http.HandleFunc("/contact", contactHandler)
    
    // Prefix matches (with trailing slash)
    http.HandleFunc("/api/", apiHandler)
    http.HandleFunc("/users/", usersHandler)
    
    // That's about it!
}

func usersHandler(w http.ResponseWriter, r *http.Request) {
    // With standard library, YOU have to parse the URL manually
    path := r.URL.Path                    // "/users/123/posts/456"
    parts := strings.Split(path, "/")     // ["", "users", "123", "posts", "456"]
    
    if len(parts) < 3 {
        http.NotFound(w, r)
        return
    }
    
    userID := parts[2] // "123" - manually extracted
    
    // YOU have to handle different HTTP methods manually
    switch r.Method {
    case "GET":
        getUserHandler(w, r, userID)
    case "PUT":
        updateUserHandler(w, r, userID)
    case "DELETE":
        deleteUserHandler(w, r, userID)
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
    }
}
```

### What Standard Library CAN'T Do Easily

```go
// These patterns are difficult/impossible with standard library:

// 1. URL Parameters - NO built-in support
// Want: /users/{id} to automatically extract "id"
// Reality: Manual string parsing required

// 2. HTTP Method Routing - NO built-in support
// Want: GET /users/{id} vs POST /users to different handlers
// Reality: Manual method checking in every handler

// 3. Middleware Chains - NO built-in support
// Want: logging -> auth -> rate limiting -> handler
// Reality: Manual wrapper functions

// 4. Route Groups - NO built-in support
// Want: /api/v1/* with shared middleware
// Reality: Repetitive handler registration

// 5. Query Parameter Validation - NO built-in support
// Want: /search?q={required}&limit={optional,number}
// Reality: Manual validation in every handler

// 6. Nested Routes - NO built-in support
// Want: /users/{id}/posts/{postId}
// Reality: Complex manual parsing
```

### Why This Becomes Problematic

```go
// Example: A simple REST API with standard library
func standardLibraryProblems() {
    // Every handler needs manual work:
    
    http.HandleFunc("/api/users/", func(w http.ResponseWriter, r *http.Request) {
        // 1. Parse URL manually
        path := strings.TrimPrefix(r.URL.Path, "/api/users/")
        segments := strings.Split(path, "/")
        
        // 2. Handle different URL patterns manually
        switch len(segments) {
        case 1 && segments[0] == "":
            // /api/users/
            handleUsersList(w, r)
        case 1:
            // /api/users/{id}
            userID := segments[0]
            handleSingleUser(w, r, userID)
        case 2 && segments[1] == "posts":
            // /api/users/{id}/posts
            userID := segments[0]
            handleUserPosts(w, r, userID)
        default:
            http.NotFound(w, r)
        }
    })
    
    // This becomes unmaintainable quickly!
}
```

---

## What is Advanced Routing?

### Core Concepts of Advanced Routing

Advanced routing provides **automatic pattern matching** and **parameter extraction**:

```go
// What we want to achieve:
type ModernRouter interface {
    // 1. URL Parameters - automatic extraction
    GET("/users/{id}", getUserHandler)
    POST("/users", createUserHandler)
    PUT("/users/{id}", updateUserHandler)
    DELETE("/users/{id}", deleteUserHandler)
    
    // 2. Nested parameters
    GET("/users/{userID}/posts/{postID}", getUserPostHandler)
    
    // 3. Method-specific routing
    Route("/users/{id}").
        GET(getUserHandler).
        PUT(updateUserHandler).
        DELETE(deleteUserHandler)
    
    // 4. Middleware chains
    Use(LoggingMiddleware, AuthMiddleware)
    
    // 5. Route groups
    Group("/api/v1", func(r Router) {
        r.Use(APIMiddleware)
        r.GET("/users", getUsersHandler)
    })
}
```

### How Advanced Routers Work Internally

```go
// Conceptual implementation of how modern routers work:

type Route struct {
    Method      string              // "GET", "POST", etc.
    Pattern     string              // "/users/{id}"
    Handler     http.HandlerFunc    // The handler function
    Params      []string            // ["id"] - parameter names
    Middleware  []Middleware        // Chain of middleware
}

type Router struct {
    routes     []Route
    middleware []Middleware
}

func (router *Router) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 1. Find matching route
    route, params := router.findRoute(r.Method, r.URL.Path)
    if route == nil {
        http.NotFound(w, r)
        return
    }
    
    // 2. Extract URL parameters
    ctx := context.WithValue(r.Context(), "params", params)
    r = r.WithContext(ctx)
    
    // 3. Build middleware chain
    handler := route.Handler
    for i := len(route.Middleware) - 1; i >= 0; i-- {
        handler = route.Middleware[i](handler)
    }
    
    // 4. Execute handler
    handler(w, r)
}

func (router *Router) findRoute(method, path string) (*Route, map[string]string) {
    for _, route := range router.routes {
        if route.Method != method {
            continue
        }
        
        if params := matchPattern(route.Pattern, path); params != nil {
            return &route, params
        }
    }
    return nil, nil
}

func matchPattern(pattern, path string) map[string]string {
    // Convert "/users/{id}" to regex and extract parameters
    // This is where the magic happens!
    
    // Pattern: "/users/{id}"
    // Path:    "/users/123"
    // Result:  map[string]string{"id": "123"}
}
```

---

## Understanding URL Parameters

### What Are URL Parameters?

URL parameters are **dynamic parts** of URLs that can change:

```
URL Pattern:     /users/{id}
Actual URLs:     /users/123
                 /users/456
                 /users/abc

Parameter:       id = "123", "456", "abc"

Complex Pattern: /users/{userID}/posts/{postID}
Actual URL:      /users/123/posts/456
Parameters:      userID = "123", postID = "456"
```

### How Parameter Extraction Works

```go
// This is conceptually how routers extract parameters:

func extractParameters(pattern, path string) map[string]string {
    // Pattern: "/users/{id}/posts/{postID}"
    // Path:    "/users/123/posts/456"
    
    patternParts := strings.Split(pattern, "/") // ["", "users", "{id}", "posts", "{postID}"]
    pathParts := strings.Split(path, "/")       // ["", "users", "123", "posts", "456"]
    
    if len(patternParts) != len(pathParts) {
        return nil // No match
    }
    
    params := make(map[string]string)
    
    for i, patternPart := range patternParts {
        if strings.HasPrefix(patternPart, "{") && strings.HasSuffix(patternPart, "}") {
            // This is a parameter
            paramName := patternPart[1 : len(patternPart)-1] // Remove { }
            paramValue := pathParts[i]
            params[paramName] = paramValue
        } else if patternPart != pathParts[i] {
            return nil // Static parts don't match
        }
    }
    
    return params
}

// Example usage:
// pattern = "/users/{id}/posts/{postID}"
// path = "/users/123/posts/456"
// result = map[string]string{"id": "123", "postID": "456"}
```

### Parameter Types and Validation

```go
// Advanced routers often support parameter types:

func parameterTypes() {
    // Basic string parameters (default)
    router.GET("/users/{id}", handler)           // id = "123" (string)
    
    // Numeric parameters
    router.GET("/users/{id:[0-9]+}", handler)    // id = only numbers
    
    // Specific patterns
    router.GET("/files/{name}.{ext}", handler)   // name + ext separately
    
    // Optional parameters
    router.GET("/search/{query?}", handler)      // query might be empty
    
    // Wildcard/catch-all
    router.GET("/static/*", handler)             // matches /static/anything/here
}

func handler(w http.ResponseWriter, r *http.Request) {
    // How to access extracted parameters (varies by router):
    
    // Chi router style:
    id := chi.URLParam(r, "id")
    
    // Gorilla mux style:
    vars := mux.Vars(r)
    id := vars["id"]
    
    // Generic context style:
    params := r.Context().Value("params").(map[string]string)
    id := params["id"]
}
```

---

## Introduction to Modern Routers

### Popular Go Routers Comparison

```go
// 1. Chi Router - Lightweight, idiomatic Go
import "github.com/go-chi/chi/v5"

// 2. Gorilla Mux - Feature-rich, mature
import "github.com/gorilla/mux"

// 3. Gin - High performance, full framework
import "github.com/gin-gonic/gin"

// 4. Echo - High performance, minimalist
import "github.com/labstack/echo/v4"

// 5. Fiber - Express.js-inspired, very fast
import "github.com/gofiber/fiber/v2"

func routerComparison() {
    // Chi - Balanced, Go-idiomatic
    chi_router := chi.NewRouter()
    chi_router.Get("/users/{id}", handler)
    
    // Gorilla Mux - Feature-complete
    gorilla_router := mux.NewRouter()
    gorilla_router.HandleFunc("/users/{id}", handler).Methods("GET")
    
    // They all solve the same core problems:
    // 1. URL parameter extraction
    // 2. HTTP method routing
    // 3. Middleware support
    // 4. Route organization
}
```

### Why Choose Advanced Routers?

```go
// Benefits of advanced routers:

func benefitsComparison() {
    // Standard Library Problems:
    standardHandler := func(w http.ResponseWriter, r *http.Request) {
        // Manual URL parsing
        path := r.URL.Path
        if !strings.HasPrefix(path, "/api/users/") {
            http.NotFound(w, r)
            return
        }
        
        id := strings.TrimPrefix(path, "/api/users/")
        if id == "" {
            http.NotFound(w, r)
            return
        }
        
        // Manual method checking
        if r.Method != "GET" {
            w.WriteHeader(http.StatusMethodNotAllowed)
            return
        }
        
        // Manual logging
        log.Printf("GET /api/users/%s", id)
        
        // Finally, the actual logic
        handleGetUser(w, r, id)
    }
    
    // Advanced Router Solution:
    advancedSetup := func() {
        r := chi.NewRouter()
        
        // Middleware applies automatically
        r.Use(LoggingMiddleware)
        
        // URL parameters extracted automatically
        // HTTP method routing automatic
        r.Get("/api/users/{id}", func(w http.ResponseWriter, r *http.Request) {
            id := chi.URLParam(r, "id")
            handleGetUser(w, r, id)
        })
    }
}
```

---

## Chi Router Deep Dive

### Getting Started with Chi

```go
// First, install chi:
// go mod init myproject
// go get github.com/go-chi/chi/v5

package main

import (
    "fmt"
    "net/http"
    
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
)

func chiBasics() {
    r := chi.NewRouter()
    
    // Built-in middleware
    r.Use(middleware.Logger)    // Logs all requests
    r.Use(middleware.Recoverer) // Recovers from panics
    
    // Simple routes
    r.Get("/", homeHandler)
    r.Post("/users", createUserHandler)
    r.Get("/users/{id}", getUserHandler)
    r.Put("/users/{id}", updateUserHandler)
    r.Delete("/users/{id}", deleteUserHandler)
    
    http.ListenAndServe(":8080", r)
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    // Extract URL parameter
    userID := chi.URLParam(r, "id")
    
    fmt.Fprintf(w, "Getting user: %s", userID)
}
```

### Chi Parameter Extraction

```go
func chiParameterExamples() {
    r := chi.NewRouter()
    
    // Single parameter
    r.Get("/users/{id}", func(w http.ResponseWriter, r *http.Request) {
        id := chi.URLParam(r, "id")
        fmt.Fprintf(w, "User ID: %s", id)
    })
    
    // Multiple parameters
    r.Get("/users/{userID}/posts/{postID}", func(w http.ResponseWriter, r *http.Request) {
        userID := chi.URLParam(r, "userID")
        postID := chi.URLParam(r, "postID")
        fmt.Fprintf(w, "User: %s, Post: %s", userID, postID)
    })
    
    // Parameter with regex pattern
    r.Get("/users/{id:[0-9]+}", func(w http.ResponseWriter, r *http.Request) {
        id := chi.URLParam(r, "id") // Only matches numeric IDs
        fmt.Fprintf(w, "Numeric User ID: %s", id)
    })
    
    // Wildcard parameters
    r.Get("/files/*", func(w http.ResponseWriter, r *http.Request) {
        wildcard := chi.URLParam(r, "*")
        fmt.Fprintf(w, "File path: %s", wildcard)
    })
}
```

### Chi Route Groups

```go
func chiRouteGroups() {
    r := chi.NewRouter()
    
    // API v1 routes
    r.Route("/api/v1", func(r chi.Router) {
        // Middleware only for this group
        r.Use(ApiVersionMiddleware("v1"))
        r.Use(RateLimitMiddleware)
        
        // User routes
        r.Route("/users", func(r chi.Router) {
            r.Get("/", listUsersHandler)       // GET /api/v1/users
            r.Post("/", createUserHandler)     // POST /api/v1/users
            
            r.Route("/{userID}", func(r chi.Router) {
                r.Get("/", getUserHandler)     // GET /api/v1/users/{userID}
                r.Put("/", updateUserHandler)  // PUT /api/v1/users/{userID}
                r.Delete("/", deleteUserHandler) // DELETE /api/v1/users/{userID}
                
                // Nested routes
                r.Get("/posts", getUserPostsHandler) // GET /api/v1/users/{userID}/posts
            })
        })
        
        // Product routes
        r.Route("/products", func(r chi.Router) {
            r.Get("/", listProductsHandler)
            r.Post("/", createProductHandler)
        })
    })
    
    // API v2 routes (different structure)
    r.Route("/api/v2", func(r chi.Router) {
        r.Use(ApiVersionMiddleware("v2"))
        // Different handlers/structure for v2
    })
}
```

### Chi Middleware

```go
// Custom middleware with Chi
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Call next handler
        next.ServeHTTP(w, r)
        
        // Log after request
        duration := time.Since(start)
        log.Printf("%s %s - %v", r.Method, r.URL.Path, duration)
    })
}

func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Check authentication
        apiKey := r.Header.Get("X-API-Key")
        if apiKey != "valid-key" {
            w.WriteHeader(http.StatusUnauthorized)
            fmt.Fprintf(w, "Invalid API key")
            return
        }
        
        // Continue to next handler
        next.ServeHTTP(w, r)
    })
}

func chiMiddlewareExample() {
    r := chi.NewRouter()
    
    // Global middleware
    r.Use(LoggingMiddleware)
    r.Use(middleware.CORS(&middleware.CORSConfig{
        AllowedOrigins: []string{"*"},
        AllowedMethods: []string{"GET", "POST", "PUT", "DELETE"},
    }))
    
    // Protected routes
    r.Group(func(r chi.Router) {
        r.Use(AuthMiddleware) // Only applies to this group
        
        r.Get("/admin/users", adminUsersHandler)
        r.Post("/admin/settings", adminSettingsHandler)
    })
    
    // Public routes (no auth middleware)
    r.Get("/public/info", publicInfoHandler)
}
```

---

## Gorilla Mux Router

### Getting Started with Gorilla Mux

```go
// Install: go get github.com/gorilla/mux

package main

import (
    "fmt"
    "net/http"
    
    "github.com/gorilla/mux"
)

func muxBasics() {
    r := mux.NewRouter()
    
    // Basic routes
    r.HandleFunc("/", homeHandler)
    r.HandleFunc("/users", usersHandler).Methods("GET")
    r.HandleFunc("/users", createUserHandler).Methods("POST")
    r.HandleFunc("/users/{id}", getUserHandler).Methods("GET")
    r.HandleFunc("/users/{id}", updateUserHandler).Methods("PUT")
    r.HandleFunc("/users/{id}", deleteUserHandler).Methods("DELETE")
    
    http.ListenAndServe(":8080", r)
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    // Extract URL parameters
    vars := mux.Vars(r)
    userID := vars["id"]
    
    fmt.Fprintf(w, "Getting user: %s", userID)
}
```

### Mux Advanced Features

```go
func muxAdvancedFeatures() {
    r := mux.NewRouter()
    
    // Parameter patterns
    r.HandleFunc("/users/{id:[0-9]+}", getUserHandler)              // Only digits
    r.HandleFunc("/files/{name}.{ext}", getFileHandler)             // File with extension
    r.HandleFunc("/search/{query}", searchHandler)                  // Any string
    
    // Host-based routing
    r.Host("api.example.com").HandlerFunc("/users", apiUsersHandler)
    r.Host("admin.example.com").HandlerFunc("/users", adminUsersHandler)
    
    // Scheme-based routing
    r.Schemes("https").HandlerFunc("/secure", secureHandler)
    
    // Header-based routing
    r.Headers("X-API-Version", "v1").HandlerFunc("/data", v1DataHandler)
    r.Headers("X-API-Version", "v2").HandlerFunc("/data", v2DataHandler)
    
    // Query parameter routing
    r.Queries("format", "json").HandlerFunc("/export", jsonExportHandler)
    r.Queries("format", "xml").HandlerFunc("/export", xmlExportHandler)
    
    // Combine multiple conditions
    r.HandleFunc("/api/users/{id:[0-9]+}", apiGetUserHandler).
        Methods("GET").
        Headers("Content-Type", "application/json").
        Schemes("https")
}

func getFileHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    filename := vars["name"]
    extension := vars["ext"]
    
    fmt.Fprintf(w, "File: %s.%s", filename, extension)
}
```

### Mux Subrouters

```go
func muxSubrouters() {
    r := mux.NewRouter()
    
    // API subrouter
    api := r.PathPrefix("/api").Subrouter()
    api.Use(LoggingMiddleware)
    api.Use(AuthMiddleware)
    
    // Version 1 API
    v1 := api.PathPrefix("/v1").Subrouter()
    v1.HandleFunc("/users", v1ListUsersHandler).Methods("GET")
    v1.HandleFunc("/users/{id}", v1GetUserHandler).Methods("GET")
    
    // Version 2 API
    v2 := api.PathPrefix("/v2").Subrouter()
    v2.HandleFunc("/users", v2ListUsersHandler).Methods("GET")
    v2.HandleFunc("/users/{id}", v2GetUserHandler).Methods("GET")
    
    // Admin subrouter
    admin := r.PathPrefix("/admin").Subrouter()
    admin.Use(AdminAuthMiddleware)
    admin.HandleFunc("/stats", adminStatsHandler)
    admin.HandleFunc("/users", adminUsersHandler)
    
    // Static files
    static := r.PathPrefix("/static/").Subrouter()
    static.Handler("/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static/"))))
}
```

---

## Middleware Concepts

### Understanding Middleware

Middleware is code that runs **before and/or after** your handler:

```go
// Conceptual middleware flow:
// Request → Middleware 1 → Middleware 2 → Handler → Middleware 2 → Middleware 1 → Response

func middlewareFlow() {
    // This is what happens:
    
    // 1. Request comes in
    // 2. Logging middleware starts timer
    // 3. Auth middleware checks credentials
    // 4. Rate limit middleware checks limits
    // 5. Your handler runs
    // 6. Rate limit middleware updates counters
    // 7. Auth middleware logs access
    // 8. Logging middleware logs duration
    // 9. Response sent
}
```

### Middleware Pattern in Go

```go
// Middleware signature
type Middleware func(http.Handler) http.Handler

// Basic middleware implementation
func ExampleMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Do something before handler
        fmt.Println("Before handler")
        
        // Call next handler
        next.ServeHTTP(w, r)
        
        // Do something after handler
        fmt.Println("After handler")
    })
}

// Middleware with configuration
func TimingMiddleware(name string) Middleware {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            next.ServeHTTP(w, r)
            
            duration := time.Since(start)
            log.Printf("%s took %v", name, duration)
        })
    }
}
```

### Common Middleware Examples

```go
// 1. Logging Middleware
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Printf("Starting %s %s", r.Method, r.URL.Path)
        
        next.ServeHTTP(w, r)
        
        log.Printf("Completed %s %s", r.Method, r.URL.Path)
    })
}

// 2. Authentication Middleware
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        
        if !isValidToken(token) {
            w.WriteHeader(http.StatusUnauthorized)
            fmt.Fprintf(w, "Invalid authentication token")
            return
        }
        
        // Add user info to context
        userID := getUserIDFromToken(token)
        ctx := context.WithValue(r.Context(), "userID", userID)
        r = r.WithContext(ctx)
        
        next.ServeHTTP(w, r)
    })
}

// 3. CORS Middleware
func CORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// 4. Rate Limiting Middleware
func RateLimitMiddleware(requestsPerMinute int) Middleware {
    limiter := rate.NewLimiter(rate.Limit(requestsPerMinute), requestsPerMinute)
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if !limiter.Allow() {
                w.WriteHeader(http.StatusTooManyRequests)
                fmt.Fprintf(w, "Rate limit exceeded")
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}

// 5. Recovery Middleware
func RecoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic recovered: %v", err)
                w.WriteHeader(http.StatusInternalServerError)
                fmt.Fprintf(w, "Internal server error")
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}
```

---

## Route Groups and Organization

### Organizing Routes by Feature

```go
func organizeRoutesByFeature() {
    r := chi.NewRouter()
    
    // Global middleware
    r.Use(LoggingMiddleware)
    r.Use(RecoveryMiddleware)
    r.Use(CORSMiddleware)
    
    // Public routes
    r.Group(func(r chi.Router) {
        r.Get("/health", healthCheckHandler)
        r.Get("/version", versionHandler)
        r.Post("/auth/login", loginHandler)
    })
    
    // Authenticated routes
    r.Group(func(r chi.Router) {
        r.Use(AuthMiddleware)
        
        // User management
        r.Route("/users", userRoutes)
        
        // Product management
        r.Route("/products", productRoutes)
        
        // Order management
        r.Route("/orders", orderRoutes)
    })
    
    // Admin routes
    r.Group(func(r chi.Router) {
        r.Use(AuthMiddleware)
        r.Use(AdminMiddleware)
        
        r.Route("/admin", adminRoutes)
    })
}

// Separate route definitions for clarity
func userRoutes(r chi.Router) {
    r.Get("/", listUsersHandler)           // GET /users
    r.Post("/", createUserHandler)         // POST /users
    
    r.Route("/{userID}", func(r chi.Router) {
        r.Use(UserContextMiddleware) // Load user into context
        
        r.Get("/", getUserHandler)         // GET /users/{userID}
        r.Put("/", updateUserHandler)      // PUT /users/{userID}
        r.Delete("/", deleteUserHandler)   // DELETE /users/{userID}
        
        // User's posts
        r.Route("/posts", func(r chi.Router) {
            r.Get("/", getUserPostsHandler)    // GET /users/{userID}/posts
            r.Post("/", createUserPostHandler) // POST /users/{userID}/posts
            
            r.Route("/{postID}", func(r chi.Router) {
                r.Get("/", getUserPostHandler)    // GET /users/{userID}/posts/{postID}
                r.Put("/", updateUserPostHandler) // PUT /users/{userID}/posts/{postID}
                r.Delete("/", deleteUserPostHandler) // DELETE /users/{userID}/posts/{postID}
            })
        })
    })
}

func productRoutes(r chi.Router) {
    r.Get("/", listProductsHandler)
    r.Post("/", createProductHandler)
    
    r.Route("/{productID}", func(r chi.Router) {
        r.Get("/", getProductHandler)
        r.Put("/", updateProductHandler)
        r.Delete("/", deleteProductHandler)
        
        // Product reviews
        r.Get("/reviews", getProductReviewsHandler)
        r.Post("/reviews", createProductReviewHandler)
    })
}
```

### API Versioning with Route Groups

```go
func apiVersioningExample() {
    r := chi.NewRouter()
    
    // API v1
    r.Route("/api/v1", func(r chi.Router) {
        r.Use(ApiVersionMiddleware("v1"))
        r.Use(RateLimitMiddleware(100)) // 100 requests per minute
        
        r.Get("/users", v1ListUsersHandler)
        r.Post("/users", v1CreateUserHandler)
        r.Get("/users/{id}", v1GetUserHandler)
    })
    
    // API v2 - Different structure, enhanced features
    r.Route("/api/v2", func(r chi.Router) {
        r.Use(ApiVersionMiddleware("v2"))
        r.Use(RateLimitMiddleware(200)) // Higher rate limit for v2
        
        // Enhanced user endpoints
        r.Route("/users", func(r chi.Router) {
            r.Get("/", v2ListUsersHandler)     // Supports pagination, filtering
            r.Post("/", v2CreateUserHandler)   // Enhanced validation
            
            r.Route("/{id}", func(r chi.Router) {
                r.Get("/", v2GetUserHandler)     // Includes more fields
                r.Put("/", v2UpdateUserHandler)  // Partial updates
                r.Delete("/", v2DeleteUserHandler)
                
                // New in v2: User preferences
                r.Get("/preferences", v2GetUserPreferencesHandler)
                r.Put("/preferences", v2UpdateUserPreferencesHandler)
            })
        })
        
        // New in v2: Analytics endpoints
        r.Route("/analytics", func(r chi.Router) {
            r.Use(AnalyticsAuthMiddleware)
            
            r.Get("/users", getUserAnalyticsHandler)
            r.Get("/usage", getUsageAnalyticsHandler)
        })
    })
}
```

---

## Real-World Routing Examples

### Example 1: E-commerce API with Chi

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "strings"
    "time"
    
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
)

type Product struct {
    ID          int     `json:"id"`
    Name        string  `json:"name"`
    Price       float64 `json:"price"`
    Category    string  `json:"category"`
    InStock     bool    `json:"in_stock"`
    Description string  `json:"description"`
}

type Order struct {
    ID        int       `json:"id"`
    UserID    int       `json:"user_id"`
    Products  []Product `json:"products"`
    Total     float64   `json:"total"`
    Status    string    `json:"status"`
    CreatedAt time.Time `json:"created_at"`
}

var products = []Product{
    {ID: 1, Name: "Laptop", Price: 999.99, Category: "electronics", InStock: true, Description: "High-performance laptop"},
    {ID: 2, Name: "Mouse", Price: 29.99, Category: "electronics", InStock: true, Description: "Wireless mouse"},
    {ID: 3, Name: "Book", Price: 19.99, Category: "books", InStock: false, Description: "Programming guide"},
}

var orders = []Order{
    {ID: 1, UserID: 123, Products: products[:1], Total: 999.99, Status: "shipped", CreatedAt: time.Now()},
}

func main() {
    r := chi.NewRouter()
    
    // Global middleware
    r.Use(middleware.Logger)
    r.Use(middleware.Recoverer)
    r.Use(CORSMiddleware)
    
    // Public routes
    r.Get("/health", healthHandler)
    
    // API routes
    r.Route("/api/v1", func(r chi.Router) {
        r.Use(RequestIDMiddleware)
        r.Use(TimingMiddleware)
        
        // Product routes
        r.Route("/products", func(r chi.Router) {
            r.Get("/", listProductsHandler)        // GET /api/v1/products
            r.Post("/", createProductHandler)      // POST /api/v1/products
            
            r.Route("/{productID}", func(r chi.Router) {
                r.Use(ProductContextMiddleware)     // Load product into context
                
                r.Get("/", getProductHandler)      // GET /api/v1/products/{id}
                r.Put("/", updateProductHandler)   // PUT /api/v1/products/{id}
                r.Delete("/", deleteProductHandler) // DELETE /api/v1/products/{id}
            })
            
            // Product search and filtering
            r.Get("/search", searchProductsHandler)        // GET /api/v1/products/search?q=laptop
            r.Get("/category/{category}", getProductsByCategoryHandler) // GET /api/v1/products/category/electronics
        })
        
        // Order routes (require authentication)
        r.Route("/orders", func(r chi.Router) {
            r.Use(AuthMiddleware)
            
            r.Get("/", listOrdersHandler)          // GET /api/v1/orders
            r.Post("/", createOrderHandler)        // POST /api/v1/orders
            
            r.Route("/{orderID}", func(r chi.Router) {
                r.Use(OrderContextMiddleware)
                
                r.Get("/", getOrderHandler)        // GET /api/v1/orders/{id}
                r.Put("/status", updateOrderStatusHandler) // PUT /api/v1/orders/{id}/status
                r.Delete("/", cancelOrderHandler)  // DELETE /api/v1/orders/{id}
            })
        })
        
        // User routes
        r.Route("/users/{userID}", func(r chi.Router) {
            r.Use(AuthMiddleware)
            r.Use(UserAuthorizationMiddleware) // Ensure user can only access their own data
            
            r.Get("/orders", getUserOrdersHandler)     // GET /api/v1/users/{userID}/orders
            r.Get("/profile", getUserProfileHandler)   // GET /api/v1/users/{userID}/profile
        })
    })
    
    // Admin routes
    r.Route("/admin", func(r chi.Router) {
        r.Use(AuthMiddleware)
        r.Use(AdminMiddleware)
        
        r.Get("/stats", adminStatsHandler)
        r.Get("/orders", adminOrdersHandler)
        r.Get("/users", adminUsersHandler)
    })
    
    fmt.Println("E-commerce API server starting on :8080")
    http.ListenAndServe(":8080", r)
}

// Handlers
func listProductsHandler(w http.ResponseWriter, r *http.Request) {
    // Support filtering and pagination
    category := r.URL.Query().Get("category")
    inStockOnly := r.URL.Query().Get("in_stock") == "true"
    
    filteredProducts := products
    
    if category != "" {
        var filtered []Product
        for _, p := range filteredProducts {
            if p.Category == category {
                filtered = append(filtered, p)
            }
        }
        filteredProducts = filtered
    }
    
    if inStockOnly {
        var filtered []Product
        for _, p := range filteredProducts {
            if p.InStock {
                filtered = append(filtered, p)
            }
        }
        filteredProducts = filtered
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "products": filteredProducts,
        "total":    len(filteredProducts),
    })
}

func getProductHandler(w http.ResponseWriter, r *http.Request) {
    // Product loaded by middleware
    product := r.Context().Value("product").(Product)
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(product)
}

func searchProductsHandler(w http.ResponseWriter, r *http.Request) {
    query := r.URL.Query().Get("q")
    if query == "" {
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Query parameter 'q' is required",
        })
        return
    }
    
    var results []Product
    for _, p := range products {
        if contains(p.Name, query) || contains(p.Description, query) {
            results = append(results, p)
        }
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "query":   query,
        "results": results,
        "count":   len(results),
    })
}

func getProductsByCategoryHandler(w http.ResponseWriter, r *http.Request) {
    category := chi.URLParam(r, "category")
    
    var categoryProducts []Product
    for _, p := range products {
        if p.Category == category {
            categoryProducts = append(categoryProducts, p)
        }
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "category": category,
        "products": categoryProducts,
        "count":    len(categoryProducts),
    })
}

// Middleware
func ProductContextMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        productIDStr := chi.URLParam(r, "productID")
        productID, err := strconv.Atoi(productIDStr)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Invalid product ID",
            })
            return
        }
        
        // Find product
        var product *Product
        for _, p := range products {
            if p.ID == productID {
                product = &p
                break
            }
        }
        
        if product == nil {
            w.WriteHeader(http.StatusNotFound)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Product not found",
            })
            return
        }
        
        // Add product to context
        ctx := context.WithValue(r.Context(), "product", *product)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func RequestIDMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        requestID := fmt.Sprintf("req-%d", time.Now().UnixNano())
        w.Header().Set("X-Request-ID", requestID)
        
        ctx := context.WithValue(r.Context(), "requestID", requestID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func TimingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        next.ServeHTTP(w, r)
        
        duration := time.Since(start)
        w.Header().Set("X-Response-Time", duration.String())
    })
}

func CORSMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Simplified auth check
        token := r.Header.Get("Authorization")
        if token != "Bearer valid-token" {
            w.WriteHeader(http.StatusUnauthorized)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Invalid authorization token",
            })
            return
        }
        
        next.ServeHTTP(w, r)
    })
}

// Helper functions
func contains(str, substr string) bool {
    return strings.Contains(strings.ToLower(str), strings.ToLower(substr))
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "status":    "healthy",
        "timestamp": time.Now(),
        "version":   "1.0.0",
    })
}

// Placeholder handlers
func createProductHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Create product handler")
}

func updateProductHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Update product handler")
}

func deleteProductHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Delete product handler")
}

func listOrdersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "List orders handler")
}

func createOrderHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Create order handler")
}

func getOrderHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Get order handler")
}

func updateOrderStatusHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Update order status handler")
}

func cancelOrderHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Cancel order handler")
}

func getUserOrdersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Get user orders handler")
}

func getUserProfileHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Get user profile handler")
}

func adminStatsHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Admin stats handler")
}

func adminOrdersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Admin orders handler")
}

func adminUsersHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Admin users handler")
}

func OrderContextMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        next.ServeHTTP(w, r)
    })
}

func UserAuthorizationMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        next.ServeHTTP(w, r)
    })
}

func AdminMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        next.ServeHTTP(w, r)
    })
}
```

---

## Performance and Best Practices

### Router Performance Comparison

```go
// Performance characteristics of different routers:

func routerPerformance() {
    // 1. Standard Library
    // - Pros: Built-in, no dependencies, simple
    // - Cons: Manual parsing, limited features
    // - Performance: Good for simple apps
    
    // 2. Chi Router
    // - Pros: Lightweight, fast, Go-idiomatic, good middleware support
    // - Cons: Fewer features than Gorilla Mux
    // - Performance: Very fast, minimal overhead
    
    // 3. Gorilla Mux
    // - Pros: Feature-rich, mature, extensive matching options
    // - Cons: Heavier, more complex
    // - Performance: Good, but slower than Chi for simple routes
    
    // 4. Gin Framework
    // - Pros: Very fast, full framework features
    // - Cons: Different API style, more opinionated
    // - Performance: Fastest for high-throughput applications
}
```

### Best Practices

```go
func routingBestPractices() {
    // 1. Organize routes logically
    organizationExample := func() {
        r := chi.NewRouter()
        
        // Group related routes
        r.Route("/api/v1", func(r chi.Router) {
            r.Route("/users", userRoutes)
            r.Route("/products", productRoutes)
            r.Route("/orders", orderRoutes)
        })
    }
    
    // 2. Use middleware effectively
    middlewareExample := func() {
        r := chi.NewRouter()
        
        // Global middleware
        r.Use(LoggingMiddleware)
        r.Use(RecoveryMiddleware)
        
        // Specific middleware for groups
        r.Group(func(r chi.Router) {
            r.Use(AuthMiddleware)
            r.Get("/protected", protectedHandler)
        })
    }
    
    // 3. Validate parameters early
    validationExample := func() {
        r := chi.NewRouter()
        
        r.Route("/users/{userID:[0-9]+}", func(r chi.Router) {
            r.Use(func(next http.Handler) http.Handler {
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                    userID := chi.URLParam(r, "userID")
                    if userID == "" {
                        w.WriteHeader(http.StatusBadRequest)
                        return
                    }
                    next.ServeHTTP(w, r)
                })
            })
            
            r.Get("/", getUserHandler)
        })
    }
    
    // 4. Use context for request-scoped data
    contextExample := func() {
        r := chi.NewRouter()
        
        r.Use(func(next http.Handler) http.Handler {
            return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                requestID := generateRequestID()
                ctx := context.WithValue(r.Context(), "requestID", requestID)
                next.ServeHTTP(w, r.WithContext(ctx))
            })
        })
    }
    
    // 5. Handle errors consistently
    errorHandlingExample := func() {
        handleError := func(w http.ResponseWriter, statusCode int, message string) {
            w.WriteHeader(statusCode)
            json.NewEncoder(w).Encode(map[string]string{
                "error": message,
            })
        }
        
        r := chi.NewRouter()
        r.Get("/users/{id}", func(w http.ResponseWriter, r *http.Request) {
            id := chi.URLParam(r, "id")
            
            user, err := findUser(id)
            if err != nil {
                handleError(w, http.StatusNotFound, "User not found")
                return
            }
            
            json.NewEncoder(w).Encode(user)
        })
    }
}

func generateRequestID() string {
    return fmt.Sprintf("req-%d", time.Now().UnixNano())
}

func findUser(id string) (interface{}, error) {
    // Placeholder function
    return nil, fmt.Errorf("user not found")
}

func protectedHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Protected resource")
}

func userRoutes(r chi.Router) {
    r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "User routes")
    })
}

func productRoutes(r chi.Router) {
    r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Product routes")
    })
}

func orderRoutes(r chi.Router) {
    r.Get("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Order routes")
    })
}

func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        log.Printf("Starting %s %s", r.Method, r.URL.Path)
        next.ServeHTTP(w, r)
        log.Printf("Completed %s %s", r.Method, r.URL.Path)
    })
}

func RecoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic recovered: %v", err)
                w.WriteHeader(http.StatusInternalServerError)
                fmt.Fprintf(w, "Internal server error")
            }
        }()
        next.ServeHTTP(w, r)
    })
}
```

### Common Pitfalls

```go
func commonRoutingPitfalls() {
    // 1. Route order matters
    routeOrderProblem := func() {
        r := chi.NewRouter()
        
        // ❌ Wrong order
        r.Get("/users/*", catchAllHandler)      // This catches everything!
        r.Get("/users/{id}", getUserHandler)    // This never runs
        
        // ✅ Correct order
        r.Get("/users/{id}", getUserHandler)    // Specific routes first
        r.Get("/users/*", catchAllHandler)      // Catch-all routes last
    }
    
    // 2. Not validating parameters
    noValidationProblem := func() {
        r := chi.NewRouter()
        
        // ❌ No validation
        r.Get("/users/{id}", func(w http.ResponseWriter, r *http.Request) {
            id := chi.URLParam(r, "id")
            // What if id is empty or invalid?
            // user := database.GetUser(id) // Might panic or return wrong data
        })
        
        // ✅ With validation
        r.Get("/users/{id:[0-9]+}", func(w http.ResponseWriter, r *http.Request) {
            id := chi.URLParam(r, "id")
            userID, err := strconv.Atoi(id)
            if err != nil {
                w.WriteHeader(http.StatusBadRequest)
                return
            }
            // Now safe to use userID
            _ = userID
        })
    }
    
    // 3. Middleware order matters
    middlewareOrderProblem := func() {
        r := chi.NewRouter()
        
        // ❌ Wrong order
        r.Use(AuthMiddleware)    // Checks auth first
        r.Use(LoggingMiddleware) // But logging doesn't see auth failures
        
        // ✅ Correct order
        r.Use(LoggingMiddleware) // Log everything
        r.Use(AuthMiddleware)    // Then check auth
    }
}

func catchAllHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Catch all handler")
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Get user handler")
}

func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        next.ServeHTTP(w, r)
    })
}
```

## Key Takeaways

### Advanced Routing Benefits
1. **Automatic Parameter Extraction** - No manual URL parsing
2. **HTTP Method Routing** - Route by GET, POST, PUT, DELETE automatically
3. **Middleware Support** - Clean separation of concerns
4. **Route Organization** - Group related routes logically
5. **Better Error Handling** - Consistent error responses

### Router Selection
1. **Chi** - Best balance of features and performance, Go-idiomatic
2. **Gorilla Mux** - Most features, great for complex routing needs
3. **Standard Library** - Only for very simple applications
4. **Gin/Echo** - When you need a full framework

### URL Parameters
1. **Automatic Extraction** - Routers handle the complex parsing
2. **Type Validation** - Use regex patterns to validate parameter format
3. **Context Storage** - Parameters available throughout request lifecycle
4. **Nested Parameters** - Support for complex URL structures

### Middleware
1. **Chain of Responsibility** - Each middleware can modify request/response
2. **Order Matters** - Logging before auth, recovery at the top
3. **Reusable Components** - Write once, use across many routes
4. **Request Context** - Share data between middleware and handlers

Advanced routing is essential for building maintainable, scalable web APIs in Go. It eliminates boilerplate code, provides better organization, and enables powerful features like middleware chains and automatic parameter extraction.
