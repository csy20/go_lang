# Writing Responses: Communicating Back to Clients

## Table of Contents
1. [What is an HTTP Response?](#what-is-an-http-response)
2. [Understanding HTTP Response Structure](#understanding-http-response-structure)
3. [The ResponseWriter Interface](#the-responsewriter-interface)
4. [Setting Status Codes](#setting-status-codes)
5. [Working with Headers](#working-with-headers)
6. [Writing Response Body](#writing-response-body)
7. [Response Order Rules](#response-order-rules)
8. [Different Response Types](#different-response-types)
9. [Real-World Response Examples](#real-world-response-examples)
10. [Best Practices and Common Pitfalls](#best-practices-and-common-pitfalls)

---

## What is an HTTP Response?

### Basic Concept

An **HTTP response** is the server's reply to a client's request. It's like answering a question - you need to:
1. **Status** - Tell if you understood and could fulfill the request
2. **Information** - Provide any metadata about your answer
3. **Content** - Give the actual answer/data

### The Request-Response Conversation

```
Client Request:                     Server Response:
    │                                  │
    │  "GET /users/123"                │  "200 OK"
    │  "Give me user 123"              │  "Here's the user data"
    │ ──────────────────────────────→  │  {"id": 123, "name": "John"}
    │                                  │ ←────────────────────────────
    │                                  │
    │  "POST /users"                   │  "400 Bad Request"
    │  "Create user with invalid data" │  "Missing required field: email"
    │ ──────────────────────────────→  │ ←─────────────────────────────
```

### What the Server Must Communicate

```go
// Every HTTP response must answer these questions:
type HTTPResponse struct {
    // 1. Did the request succeed?
    StatusCode int     // 200, 404, 500, etc.
    
    // 2. What kind of data am I sending?
    Headers map[string]string  // Content-Type, Content-Length, etc.
    
    // 3. What is the actual data?
    Body []byte        // HTML, JSON, images, etc.
}
```

---

## Understanding HTTP Response Structure

### Raw HTTP Response Format

```
HTTP Response on the Wire:
┌─────────────────────────────────────────┐
│ STATUS LINE: HTTP/1.1 200 OK            │ ← Status code and message
├─────────────────────────────────────────┤
│ HEADERS:                                │
│   Content-Type: application/json        │ ← Response metadata
│   Content-Length: 45                    │
│   Set-Cookie: session=abc123            │
├─────────────────────────────────────────┤
│ BODY:                                   │ ← Actual response content
│   {"id": 123, "name": "John"}           │
└─────────────────────────────────────────┘
```

### How Go Constructs This Response

```go
func explainResponseConstruction(w http.ResponseWriter, r *http.Request) {
    // This is conceptually what happens:
    
    // 1. Set headers (must happen first)
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("X-Custom-Header", "MyValue")
    
    // 2. Set status code (optional, defaults to 200)
    w.WriteHeader(http.StatusOK) // This sends status line + headers
    
    // 3. Write body (this sends the body)
    body := `{"id": 123, "name": "John"}`
    w.Write([]byte(body))
    
    // Go automatically calculates Content-Length
    // Go automatically handles HTTP protocol details
}
```

### Response Timeline

```
Handler Function Execution:
    │
    │ 1. Handler starts
    │    w.Header().Set(...)     ← Headers can be modified
    │    w.Header().Set(...)
    │
    │ 2. Write status (optional)
    │    w.WriteHeader(200)      ← Headers become "locked"
    │
    │ 3. Write body
    │    w.Write(data)           ← Response starts sending to client
    │    w.Write(more_data)      ← Can write multiple times
    │
    │ 4. Handler ends            ← Response automatically finishes
    │
```

---

## The ResponseWriter Interface

### Understanding http.ResponseWriter

The `http.ResponseWriter` is your **interface to build the HTTP response**:

```go
type ResponseWriter interface {
    // Header returns the header map that will be sent
    Header() Header
    
    // Write writes the data to the connection as part of an HTTP reply
    Write([]byte) (int, error)
    
    // WriteHeader sends an HTTP response header with the provided status code
    WriteHeader(statusCode int)
}
```

### ResponseWriter as a Builder

```go
func responseWriterAsBuilder(w http.ResponseWriter, r *http.Request) {
    // Think of ResponseWriter as building a response step by step:
    
    response := &HTTPResponse{
        StatusCode: 200,                    // Default
        Headers:    make(map[string]string), // Empty initially
        Body:       []byte{},               // Empty initially
    }
    
    // w.Header().Set() modifies response.Headers
    // w.WriteHeader() sets response.StatusCode
    // w.Write() appends to response.Body
    
    // When handler finishes, Go sends the complete response
}
```

### ResponseWriter Methods Explained

```go
func exploreResponseWriter(w http.ResponseWriter, r *http.Request) {
    // 1. Header() returns a map you can modify
    headers := w.Header()
    fmt.Printf("Header type: %T\n", headers) // http.Header (which is map[string][]string)
    
    // Add headers
    headers.Set("Content-Type", "text/plain")
    headers.Add("X-Custom", "value1")
    headers.Add("X-Custom", "value2") // Multiple values
    
    // 2. WriteHeader() sends the status line and headers
    w.WriteHeader(http.StatusCreated) // 201
    
    // 3. Write() sends body data
    n, err := w.Write([]byte("Hello, World!"))
    fmt.Printf("Wrote %d bytes, error: %v\n", n, err)
    
    // After WriteHeader or first Write, headers are locked!
}
```

### What Happens Under the Hood

```go
// This is conceptually what Go does:
type responseWriter struct {
    conn       net.Conn
    headers    http.Header
    statusCode int
    wroteHeader bool
}

func (rw *responseWriter) Header() http.Header {
    return rw.headers
}

func (rw *responseWriter) WriteHeader(code int) {
    if rw.wroteHeader {
        return // Can only write header once
    }
    
    rw.statusCode = code
    rw.wroteHeader = true
    
    // Send status line and headers to connection
    fmt.Fprintf(rw.conn, "HTTP/1.1 %d %s\r\n", code, http.StatusText(code))
    rw.headers.Write(rw.conn)
    fmt.Fprintf(rw.conn, "\r\n") // Empty line separates headers from body
}

func (rw *responseWriter) Write(data []byte) (int, error) {
    if !rw.wroteHeader {
        rw.WriteHeader(200) // Default status
    }
    
    return rw.conn.Write(data) // Send body data
}
```

---

## Setting Status Codes

### Understanding HTTP Status Codes

Status codes tell the client **what happened** with their request:

```go
// Status code categories:
const (
    // 1xx: Informational (rare in typical APIs)
    StatusContinue = 100
    
    // 2xx: Success
    StatusOK         = 200  // Request succeeded
    StatusCreated    = 201  // Resource created
    StatusAccepted   = 202  // Request accepted for processing
    StatusNoContent  = 204  // Success, but no content to return
    
    // 3xx: Redirection
    StatusMovedPermanently = 301  // Resource moved
    StatusFound            = 302  // Resource found elsewhere
    StatusNotModified      = 304  // Resource not changed
    
    // 4xx: Client Error
    StatusBadRequest          = 400  // Invalid request
    StatusUnauthorized        = 401  // Authentication required
    StatusForbidden           = 403  // Access denied
    StatusNotFound            = 404  // Resource not found
    StatusMethodNotAllowed    = 405  // HTTP method not allowed
    StatusConflict            = 409  // Resource conflict
    StatusUnprocessableEntity = 422  // Invalid data format
    
    // 5xx: Server Error
    StatusInternalServerError = 500  // Server bug
    StatusNotImplemented      = 501  // Feature not implemented
    StatusBadGateway          = 502  // Upstream server error
    StatusServiceUnavailable  = 503  // Server overloaded
)
```

### When to Use Different Status Codes

```go
func statusCodeExamples(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    case "/success":
        // 200 OK - Standard success
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "Request successful")
        
    case "/created":
        // 201 Created - Resource was created
        w.WriteHeader(http.StatusCreated)
        fmt.Fprintf(w, "User created successfully")
        
    case "/no-content":
        // 204 No Content - Success but no data to return
        w.WriteHeader(http.StatusNoContent)
        // No body for 204
        
    case "/bad-request":
        // 400 Bad Request - Client sent invalid data
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Missing required field: email")
        
    case "/not-found":
        // 404 Not Found - Resource doesn't exist
        w.WriteHeader(http.StatusNotFound)
        fmt.Fprintf(w, "User not found")
        
    case "/server-error":
        // 500 Internal Server Error - Server bug
        w.WriteHeader(http.StatusInternalServerError)
        fmt.Fprintf(w, "Database connection failed")
    }
}
```

### Status Code Best Practices

```go
func statusCodeBestPractices() {
    // REST API status code patterns:
    
    // GET requests:
    // 200 - Found and returning data
    // 404 - Resource not found
    // 403 - Access denied
    
    // POST requests (create):
    // 201 - Created successfully
    // 400 - Invalid input data
    // 409 - Resource already exists
    
    // PUT requests (update):
    // 200 - Updated successfully
    // 404 - Resource not found
    // 400 - Invalid input data
    
    // DELETE requests:
    // 204 - Deleted successfully (no content)
    // 404 - Resource not found
    // 409 - Cannot delete (dependencies exist)
}

func handleUserCreation(w http.ResponseWriter, r *http.Request) {
    // Example of proper status code usage
    
    // Parse request data
    var user User
    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
        w.WriteHeader(http.StatusBadRequest) // 400
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Invalid JSON format",
        })
        return
    }
    
    // Validate data
    if user.Email == "" {
        w.WriteHeader(http.StatusBadRequest) // 400
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Email is required",
        })
        return
    }
    
    // Check if user already exists
    if userExists(user.Email) {
        w.WriteHeader(http.StatusConflict) // 409
        json.NewEncoder(w).Encode(map[string]string{
            "error": "User with this email already exists",
        })
        return
    }
    
    // Create user
    if err := createUser(user); err != nil {
        w.WriteHeader(http.StatusInternalServerError) // 500
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Failed to create user",
        })
        return
    }
    
    // Success
    w.WriteHeader(http.StatusCreated) // 201
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "message": "User created successfully",
        "user":    user,
    })
}
```

---

## Working with Headers

### Understanding HTTP Headers

Headers provide **metadata** about the response:

```go
// Common response headers:
func explainCommonHeaders() {
    headers := map[string]string{
        // Content information
        "Content-Type":   "application/json",      // What type of data
        "Content-Length": "1234",                  // How much data (auto-calculated)
        "Content-Encoding": "gzip",                // Is data compressed
        
        // Caching
        "Cache-Control": "no-cache",               // How to cache
        "ETag":         "\"abc123\"",              // Version identifier
        "Expires":      "Wed, 21 Oct 2015 07:28:00 GMT", // When expires
        
        // Security
        "X-Frame-Options":        "DENY",          // Prevent iframe embedding
        "X-Content-Type-Options": "nosniff",       // Prevent MIME sniffing
        "X-XSS-Protection":       "1; mode=block", // XSS protection
        
        // Custom headers (start with X-)
        "X-Request-ID":  "req-123456",             // Request tracking
        "X-Rate-Limit":  "100",                    // API rate limit info
        "X-Powered-By":  "Go/1.21",               // Technology info
    }
}
```

### Setting Headers in Go

```go
func setHeadersExample(w http.ResponseWriter, r *http.Request) {
    // Get header map
    headers := w.Header()
    
    // Set single value (replaces existing)
    headers.Set("Content-Type", "application/json")
    headers.Set("X-Custom-Header", "MyValue")
    
    // Add value (allows multiple values for same header)
    headers.Add("X-Tags", "go")
    headers.Add("X-Tags", "web")
    headers.Add("X-Tags", "api")
    
    // Get header value
    contentType := headers.Get("Content-Type")
    fmt.Printf("Content-Type: %s\n", contentType)
    
    // Get all values for header
    tags := headers["X-Tags"]
    fmt.Printf("All tags: %v\n", tags) // [go web api]
    
    // Delete header
    headers.Del("X-Custom-Header")
    
    // Check if header exists
    if _, exists := headers["Content-Type"]; exists {
        fmt.Println("Content-Type header is set")
    }
}
```

### Content-Type Header Examples

```go
func contentTypeExamples(w http.ResponseWriter, r *http.Request) {
    path := r.URL.Path
    
    switch path {
    case "/json":
        w.Header().Set("Content-Type", "application/json")
        data := map[string]string{"message": "Hello, JSON!"}
        json.NewEncoder(w).Encode(data)
        
    case "/html":
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        html := "<h1>Hello, HTML!</h1>"
        fmt.Fprintf(w, html)
        
    case "/text":
        w.Header().Set("Content-Type", "text/plain; charset=utf-8")
        fmt.Fprintf(w, "Hello, plain text!")
        
    case "/xml":
        w.Header().Set("Content-Type", "application/xml")
        xml := `<?xml version="1.0"?><message>Hello, XML!</message>`
        fmt.Fprintf(w, xml)
        
    case "/css":
        w.Header().Set("Content-Type", "text/css")
        css := "body { background-color: blue; }"
        fmt.Fprintf(w, css)
        
    case "/javascript":
        w.Header().Set("Content-Type", "application/javascript")
        js := "console.log('Hello, JavaScript!');"
        fmt.Fprintf(w, js)
        
    case "/image":
        w.Header().Set("Content-Type", "image/png")
        // Would write binary image data here
        fmt.Fprintf(w, "This would be binary image data")
    }
}
```

### Custom Headers for APIs

```go
func apiHeadersExample(w http.ResponseWriter, r *http.Request) {
    // API versioning
    w.Header().Set("API-Version", "v2.1")
    
    // Rate limiting information
    w.Header().Set("X-RateLimit-Limit", "1000")
    w.Header().Set("X-RateLimit-Remaining", "999")
    w.Header().Set("X-RateLimit-Reset", "1640995200")
    
    // Request tracking
    requestID := "req-" + fmt.Sprintf("%d", time.Now().UnixNano())
    w.Header().Set("X-Request-ID", requestID)
    
    // Performance information
    w.Header().Set("X-Response-Time", "23ms")
    
    // CORS headers (for web browsers)
    w.Header().Set("Access-Control-Allow-Origin", "*")
    w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
    w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
    
    // Security headers
    w.Header().Set("X-Content-Type-Options", "nosniff")
    w.Header().Set("X-Frame-Options", "DENY")
    w.Header().Set("X-XSS-Protection", "1; mode=block")
    
    // Cache control
    w.Header().Set("Cache-Control", "no-cache, no-store, must-revalidate")
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]string{
        "message": "Headers set successfully",
        "request_id": requestID,
    })
}
```

---

## Writing Response Body

### Different Ways to Write Response Body

```go
func writeBodyMethods(w http.ResponseWriter, r *http.Request) {
    // Method 1: w.Write() with byte slice
    data := []byte("Hello, World!")
    w.Write(data)
    
    // Method 2: fmt.Fprintf() - convenient for formatted text
    fmt.Fprintf(w, "User ID: %d, Name: %s", 123, "John")
    
    // Method 3: fmt.Fprint() - print values
    fmt.Fprint(w, "Hello, ", "World!")
    
    // Method 4: io.Copy() - copy from reader
    reader := strings.NewReader("Hello from reader!")
    io.Copy(w, reader)
    
    // Method 5: json.NewEncoder() - for JSON responses
    data := map[string]string{"message": "Hello, JSON!"}
    json.NewEncoder(w).Encode(data)
}
```

### Understanding the Write Process

```go
func understandWriteProcess(w http.ResponseWriter, r *http.Request) {
    // First write automatically sends status line and headers
    fmt.Printf("Before first write - headers can still be modified\n")
    
    w.Header().Set("Content-Type", "text/plain")
    
    // This triggers sending status line and headers
    w.Write([]byte("First chunk of data\n"))
    
    fmt.Printf("After first write - headers are now locked\n")
    
    // Subsequent writes only send body data
    w.Write([]byte("Second chunk of data\n"))
    w.Write([]byte("Third chunk of data\n"))
    
    // Headers can no longer be modified
    w.Header().Set("X-Too-Late", "This won't work") // IGNORED!
}
```

### Writing Different Data Types

```go
func writeDataTypes(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Query().Get("type") {
    case "string":
        w.Header().Set("Content-Type", "text/plain")
        fmt.Fprintf(w, "This is a string response")
        
    case "number":
        w.Header().Set("Content-Type", "text/plain")
        number := 12345
        fmt.Fprintf(w, "%d", number)
        
    case "json":
        w.Header().Set("Content-Type", "application/json")
        data := map[string]interface{}{
            "name":    "John",
            "age":     30,
            "active":  true,
            "scores":  []int{85, 92, 78},
            "address": map[string]string{
                "city":  "New York",
                "state": "NY",
            },
        }
        json.NewEncoder(w).Encode(data)
        
    case "html":
        w.Header().Set("Content-Type", "text/html")
        html := `
        <!DOCTYPE html>
        <html>
        <head><title>Response</title></head>
        <body>
            <h1>Hello from Go!</h1>
            <p>Current time: %s</p>
        </body>
        </html>
        `
        fmt.Fprintf(w, html, time.Now().Format(time.RFC3339))
        
    case "binary":
        w.Header().Set("Content-Type", "application/octet-stream")
        binaryData := []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f} // "Hello" in bytes
        w.Write(binaryData)
        
    case "file":
        // Simulate serving a file
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Content-Disposition", "attachment; filename=\"data.txt\"")
        fmt.Fprintf(w, "This is file content\nLine 2\nLine 3")
        
    default:
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Unknown type parameter")
    }
}
```

---

## Response Order Rules

### Critical Order Requirements

```go
func responseOrderRules() {
    // RULE 1: Headers must be set BEFORE writing status or body
    // ✅ Correct order:
    correctOrder := func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")  // 1. Headers first
        w.Header().Set("X-Custom", "value")
        
        w.WriteHeader(http.StatusCreated)                   // 2. Status code second
        
        w.Write([]byte(`{"message": "success"}`))           // 3. Body last
    }
    
    // ❌ Wrong order:
    wrongOrder := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusCreated)                   // Headers locked here!
        
        w.Header().Set("Content-Type", "application/json")  // IGNORED!
        w.Write([]byte(`{"message": "success"}`))
    }
}
```

### What Happens When You Break the Rules

```go
func demonstrateOrderViolations(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Query().Get("demo") {
    case "headers-after-write":
        // Write body first
        w.Write([]byte("Hello"))
        
        // Try to set headers - WILL BE IGNORED
        w.Header().Set("Content-Type", "application/json") // No effect!
        w.WriteHeader(http.StatusCreated)                  // No effect!
        
        fmt.Printf("Headers after write: %v\n", w.Header())
        
    case "multiple-writeheader":
        w.WriteHeader(http.StatusOK)
        w.WriteHeader(http.StatusCreated) // IGNORED - only first one counts
        
        fmt.Fprintf(w, "Status will be 200, not 201")
        
    case "correct-order":
        // Demonstrate correct order
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("X-Demo", "correct-order")
        w.WriteHeader(http.StatusAccepted)
        w.Write([]byte(`{"status": "accepted"}`))
    }
}
```

### Safe Response Writing Patterns

```go
func safeResponsePattern(w http.ResponseWriter, r *http.Request) {
    // Pattern 1: Set everything upfront
    setupResponse := func() {
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("X-API-Version", "v1")
        // Don't call WriteHeader yet - let first Write() do it
    }
    
    // Pattern 2: Use helper function
    writeJSONResponse := func(data interface{}, statusCode int) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(data)
    }
    
    // Pattern 3: Early return pattern
    handleRequest := func() {
        // Validate input
        if r.Method != "POST" {
            w.WriteHeader(http.StatusMethodNotAllowed)
            fmt.Fprintf(w, "Only POST allowed")
            return // Exit early
        }
        
        // Set success headers
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{
            "message": "Success",
        })
    }
    
    handleRequest()
}
```

---

## Different Response Types

### JSON Responses

```go
type APIResponse struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
    Meta    *MetaInfo   `json:"meta,omitempty"`
}

type MetaInfo struct {
    Timestamp string `json:"timestamp"`
    RequestID string `json:"request_id"`
    Version   string `json:"version"`
}

func jsonResponseExamples(w http.ResponseWriter, r *http.Request) {
    // Set JSON content type
    w.Header().Set("Content-Type", "application/json")
    
    endpoint := r.URL.Path
    
    switch endpoint {
    case "/api/success":
        response := APIResponse{
            Success: true,
            Data: map[string]interface{}{
                "users": []map[string]interface{}{
                    {"id": 1, "name": "John"},
                    {"id": 2, "name": "Jane"},
                },
                "total": 2,
            },
            Meta: &MetaInfo{
                Timestamp: time.Now().Format(time.RFC3339),
                RequestID: "req-123",
                Version:   "v1.0",
            },
        }
        
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(response)
        
    case "/api/error":
        response := APIResponse{
            Success: false,
            Error:   "User not found",
            Meta: &MetaInfo{
                Timestamp: time.Now().Format(time.RFC3339),
                RequestID: "req-124",
                Version:   "v1.0",
            },
        }
        
        w.WriteHeader(http.StatusNotFound)
        json.NewEncoder(w).Encode(response)
        
    case "/api/validation-error":
        errors := []map[string]string{
            {"field": "email", "message": "Email is required"},
            {"field": "age", "message": "Age must be between 18 and 100"},
        }
        
        response := APIResponse{
            Success: false,
            Error:   "Validation failed",
            Data:    errors,
            Meta: &MetaInfo{
                Timestamp: time.Now().Format(time.RFC3339),
                RequestID: "req-125",
                Version:   "v1.0",
            },
        }
        
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(response)
    }
}
```

### HTML Responses

```go
func htmlResponseExamples(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    
    switch r.URL.Path {
    case "/simple":
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "<h1>Hello, World!</h1>")
        
    case "/template":
        html := `
        <!DOCTYPE html>
        <html>
        <head>
            <title>User Profile</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .profile { border: 1px solid #ccc; padding: 20px; border-radius: 5px; }
            </style>
        </head>
        <body>
            <div class="profile">
                <h1>User Profile</h1>
                <p><strong>Name:</strong> %s</p>
                <p><strong>Email:</strong> %s</p>
                <p><strong>Joined:</strong> %s</p>
            </div>
        </body>
        </html>
        `
        
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, html, "John Doe", "john@example.com", time.Now().Format("January 2, 2006"))
        
    case "/form":
        form := `
        <!DOCTYPE html>
        <html>
        <head><title>Contact Form</title></head>
        <body>
            <h2>Contact Us</h2>
            <form action="/submit" method="post">
                <p>
                    <label>Name:</label><br>
                    <input type="text" name="name" required>
                </p>
                <p>
                    <label>Email:</label><br>
                    <input type="email" name="email" required>
                </p>
                <p>
                    <label>Message:</label><br>
                    <textarea name="message" rows="4" cols="50" required></textarea>
                </p>
                <p>
                    <button type="submit">Send Message</button>
                </p>
            </form>
        </body>
        </html>
        `
        
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, form)
    }
}
```

### File Download Responses

```go
func fileDownloadExamples(w http.ResponseWriter, r *http.Request) {
    fileType := r.URL.Query().Get("type")
    
    switch fileType {
    case "csv":
        // CSV file download
        w.Header().Set("Content-Type", "text/csv")
        w.Header().Set("Content-Disposition", "attachment; filename=\"users.csv\"")
        
        csvData := "ID,Name,Email\n1,John,john@example.com\n2,Jane,jane@example.com"
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, csvData)
        
    case "json":
        // JSON file download
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Content-Disposition", "attachment; filename=\"data.json\"")
        
        data := map[string]interface{}{
            "users": []map[string]interface{}{
                {"id": 1, "name": "John"},
                {"id": 2, "name": "Jane"},
            },
            "exported": time.Now(),
        }
        
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(data)
        
    case "text":
        // Text file download
        w.Header().Set("Content-Type", "text/plain")
        w.Header().Set("Content-Disposition", "attachment; filename=\"report.txt\"")
        
        report := fmt.Sprintf("System Report\nGenerated: %s\n\nAll systems operational.",
            time.Now().Format(time.RFC3339))
        
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, report)
        
    default:
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Unknown file type. Use ?type=csv|json|text")
    }
}
```

### Stream Responses

```go
func streamResponseExample(w http.ResponseWriter, r *http.Request) {
    // Set headers for streaming
    w.Header().Set("Content-Type", "text/plain")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    
    // Start streaming (this sends headers)
    w.WriteHeader(http.StatusOK)
    
    // Send data in chunks
    for i := 1; i <= 10; i++ {
        message := fmt.Sprintf("Chunk %d: %s\n", i, time.Now().Format(time.RFC3339))
        w.Write([]byte(message))
        
        // Flush ensures data is sent immediately
        if flusher, ok := w.(http.Flusher); ok {
            flusher.Flush()
        }
        
        // Wait before next chunk
        time.Sleep(1 * time.Second)
    }
    
    w.Write([]byte("Stream completed!\n"))
}
```

---

## Real-World Response Examples

### Example 1: RESTful API with Proper Status Codes

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "strings"
    "time"
)

type User struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

type APIError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

var users = []User{
    {ID: 1, Name: "John Doe", Email: "john@example.com", CreatedAt: time.Now()},
    {ID: 2, Name: "Jane Smith", Email: "jane@example.com", CreatedAt: time.Now()},
}
var nextID = 3

func usersAPIHandler(w http.ResponseWriter, r *http.Request) {
    // Set common headers
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("X-API-Version", "v1.0")
    w.Header().Set("X-Request-ID", fmt.Sprintf("req-%d", time.Now().UnixNano()))
    
    switch r.Method {
    case http.MethodGet:
        handleGetUsers(w, r)
    case http.MethodPost:
        handleCreateUser(w, r)
    default:
        sendErrorResponse(w, http.StatusMethodNotAllowed, "Method not allowed", 
            fmt.Sprintf("Method %s is not allowed on this endpoint", r.Method))
    }
}

func handleGetUsers(w http.ResponseWriter, r *http.Request) {
    // Check for specific user ID in path
    path := strings.TrimPrefix(r.URL.Path, "/api/users")
    
    if path == "" || path == "/" {
        // Return all users
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]interface{}{
            "success": true,
            "data":    users,
            "count":   len(users),
        })
        return
    }
    
    // Extract user ID
    idStr := strings.Trim(path, "/")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        sendErrorResponse(w, http.StatusBadRequest, "Invalid user ID", 
            fmt.Sprintf("'%s' is not a valid user ID", idStr))
        return
    }
    
    // Find user
    for _, user := range users {
        if user.ID == id {
            w.WriteHeader(http.StatusOK)
            json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "data":    user,
            })
            return
        }
    }
    
    // User not found
    sendErrorResponse(w, http.StatusNotFound, "User not found", 
        fmt.Sprintf("User with ID %d does not exist", id))
}

func handleCreateUser(w http.ResponseWriter, r *http.Request) {
    var newUser User
    
    // Parse JSON body
    if err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {
        sendErrorResponse(w, http.StatusBadRequest, "Invalid JSON", 
            "Request body must be valid JSON")
        return
    }
    defer r.Body.Close()
    
    // Validate required fields
    if newUser.Name == "" {
        sendErrorResponse(w, http.StatusBadRequest, "Validation failed", 
            "Name is required")
        return
    }
    
    if newUser.Email == "" {
        sendErrorResponse(w, http.StatusBadRequest, "Validation failed", 
            "Email is required")
        return
    }
    
    // Check for duplicate email
    for _, user := range users {
        if user.Email == newUser.Email {
            sendErrorResponse(w, http.StatusConflict, "User already exists", 
                fmt.Sprintf("User with email '%s' already exists", newUser.Email))
            return
        }
    }
    
    // Create user
    newUser.ID = nextID
    nextID++
    newUser.CreatedAt = time.Now()
    
    users = append(users, newUser)
    
    // Return created user with 201 status
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "message": "User created successfully",
        "data":    newUser,
    })
}

func sendErrorResponse(w http.ResponseWriter, statusCode int, message, details string) {
    w.WriteHeader(statusCode)
    
    errorResponse := APIError{
        Code:    statusCode,
        Message: message,
        Details: details,
    }
    
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success":   false,
        "error":     errorResponse,
        "timestamp": time.Now().Format(time.RFC3339),
    })
}

func main() {
    http.HandleFunc("/api/users", usersAPIHandler)
    http.HandleFunc("/api/users/", usersAPIHandler)
    
    fmt.Println("REST API server starting on :8080")
    fmt.Println("Try these requests:")
    fmt.Println("  GET  http://localhost:8080/api/users")
    fmt.Println("  GET  http://localhost:8080/api/users/1")
    fmt.Println("  POST http://localhost:8080/api/users")
    fmt.Println("       Body: {\"name\": \"Alice\", \"email\": \"alice@example.com\"}")
    
    http.ListenAndServe(":8080", nil)
}
```

### Example 2: Content Negotiation API

```go
package main

import (
    "encoding/json"
    "encoding/xml"
    "fmt"
    "net/http"
    "strings"
    "time"
)

type Product struct {
    ID          int     `json:"id" xml:"id"`
    Name        string  `json:"name" xml:"name"`
    Price       float64 `json:"price" xml:"price"`
    Description string  `json:"description" xml:"description"`
    Available   bool    `json:"available" xml:"available"`
}

var products = []Product{
    {ID: 1, Name: "Laptop", Price: 999.99, Description: "High-performance laptop", Available: true},
    {ID: 2, Name: "Mouse", Price: 29.99, Description: "Wireless mouse", Available: true},
    {ID: 3, Name: "Keyboard", Price: 79.99, Description: "Mechanical keyboard", Available: false},
}

func productsHandler(w http.ResponseWriter, r *http.Request) {
    // Determine response format based on Accept header or query parameter
    format := determineResponseFormat(r)
    
    // Set common headers
    w.Header().Set("X-API-Version", "v1.0")
    w.Header().Set("X-Total-Products", fmt.Sprintf("%d", len(products)))
    
    switch format {
    case "json":
        sendJSONResponse(w, products)
    case "xml":
        sendXMLResponse(w, products)
    case "html":
        sendHTMLResponse(w, products)
    case "csv":
        sendCSVResponse(w, products)
    default:
        sendErrorResponse(w, http.StatusNotAcceptable, "Unsupported format", 
            "Supported formats: json, xml, html, csv")
    }
}

func determineResponseFormat(r *http.Request) string {
    // Check query parameter first
    if format := r.URL.Query().Get("format"); format != "" {
        return strings.ToLower(format)
    }
    
    // Check Accept header
    accept := r.Header.Get("Accept")
    switch {
    case strings.Contains(accept, "application/json"):
        return "json"
    case strings.Contains(accept, "application/xml"):
        return "xml"
    case strings.Contains(accept, "text/html"):
        return "html"
    case strings.Contains(accept, "text/csv"):
        return "csv"
    default:
        return "json" // Default to JSON
    }
}

func sendJSONResponse(w http.ResponseWriter, products []Product) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    
    response := map[string]interface{}{
        "products":  products,
        "count":     len(products),
        "timestamp": time.Now().Format(time.RFC3339),
    }
    
    json.NewEncoder(w).Encode(response)
}

func sendXMLResponse(w http.ResponseWriter, products []Product) {
    w.Header().Set("Content-Type", "application/xml")
    w.WriteHeader(http.StatusOK)
    
    type ProductsXML struct {
        XMLName   xml.Name  `xml:"products"`
        Products  []Product `xml:"product"`
        Count     int       `xml:"count,attr"`
        Timestamp string    `xml:"timestamp,attr"`
    }
    
    response := ProductsXML{
        Products:  products,
        Count:     len(products),
        Timestamp: time.Now().Format(time.RFC3339),
    }
    
    w.Write([]byte(xml.Header))
    xml.NewEncoder(w).Encode(response)
}

func sendHTMLResponse(w http.ResponseWriter, products []Product) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    
    html := `
    <!DOCTYPE html>
    <html>
    <head>
        <title>Products</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            table { border-collapse: collapse; width: 100%%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; }
            .available { color: green; }
            .unavailable { color: red; }
        </style>
    </head>
    <body>
        <h1>Products Catalog</h1>
        <p>Total products: %d</p>
        <table>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Price</th>
                <th>Description</th>
                <th>Available</th>
            </tr>
    `
    
    fmt.Fprintf(w, html, len(products))
    
    for _, product := range products {
        availability := "unavailable"
        availabilityText := "No"
        if product.Available {
            availability = "available"
            availabilityText = "Yes"
        }
        
        fmt.Fprintf(w, `
            <tr>
                <td>%d</td>
                <td>%s</td>
                <td>$%.2f</td>
                <td>%s</td>
                <td class="%s">%s</td>
            </tr>
        `, product.ID, product.Name, product.Price, product.Description, availability, availabilityText)
    }
    
    fmt.Fprintf(w, `
        </table>
        <p>Generated: %s</p>
    </body>
    </html>
    `, time.Now().Format("January 2, 2006 15:04:05"))
}

func sendCSVResponse(w http.ResponseWriter, products []Product) {
    w.Header().Set("Content-Type", "text/csv")
    w.Header().Set("Content-Disposition", "attachment; filename=\"products.csv\"")
    w.WriteHeader(http.StatusOK)
    
    // Write CSV header
    fmt.Fprintf(w, "ID,Name,Price,Description,Available\n")
    
    // Write data rows
    for _, product := range products {
        available := "false"
        if product.Available {
            available = "true"
        }
        
        // Escape quotes in description
        description := strings.ReplaceAll(product.Description, "\"", "\"\"")
        
        fmt.Fprintf(w, "%d,\"%s\",%.2f,\"%s\",%s\n",
            product.ID, product.Name, product.Price, description, available)
    }
}

func main() {
    http.HandleFunc("/products", productsHandler)
    
    fmt.Println("Content negotiation API server starting on :8080")
    fmt.Println("Try these requests:")
    fmt.Println("  GET  http://localhost:8080/products?format=json")
    fmt.Println("  GET  http://localhost:8080/products?format=xml")
    fmt.Println("  GET  http://localhost:8080/products?format=html")
    fmt.Println("  GET  http://localhost:8080/products?format=csv")
    fmt.Println("Or use Accept headers:")
    fmt.Println("  curl -H 'Accept: application/json' http://localhost:8080/products")
    fmt.Println("  curl -H 'Accept: application/xml' http://localhost:8080/products")
    
    http.ListenAndServe(":8080", nil)
}
```

---

## Best Practices and Common Pitfalls

### Best Practices

```go
func responseWritingBestPractices() {
    // 1. Always set Content-Type
    setContentType := func(w http.ResponseWriter) {
        w.Header().Set("Content-Type", "application/json") // Be explicit
    }
    
    // 2. Use appropriate status codes
    useProperStatusCodes := func(w http.ResponseWriter) {
        // Created resource
        w.WriteHeader(http.StatusCreated) // 201
        
        // Validation error
        w.WriteHeader(http.StatusBadRequest) // 400
        
        // Resource not found
        w.WriteHeader(http.StatusNotFound) // 404
        
        // Server error
        w.WriteHeader(http.StatusInternalServerError) // 500
    }
    
    // 3. Include helpful error messages
    helpfulErrors := func(w http.ResponseWriter) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        
        errorResponse := map[string]interface{}{
            "error": "Validation failed",
            "details": []map[string]string{
                {"field": "email", "message": "Email is required"},
                {"field": "age", "message": "Age must be between 18 and 100"},
            },
            "timestamp": time.Now().Format(time.RFC3339),
        }
        
        json.NewEncoder(w).Encode(errorResponse)
    }
    
    // 4. Use consistent response format
    consistentFormat := func(w http.ResponseWriter, data interface{}, err error) {
        w.Header().Set("Content-Type", "application/json")
        
        if err != nil {
            w.WriteHeader(http.StatusInternalServerError)
            json.NewEncoder(w).Encode(map[string]interface{}{
                "success": false,
                "error":   err.Error(),
            })
        } else {
            w.WriteHeader(http.StatusOK)
            json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
                "data":    data,
            })
        }
    }
}
```

### Common Pitfalls

```go
func commonPitfalls() {
    // PITFALL 1: Setting headers after writing
    badHeaderOrder := func(w http.ResponseWriter, r *http.Request) {
        // ❌ Wrong: Write first
        w.Write([]byte("Hello"))
        
        // ❌ These will be ignored!
        w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusCreated)
    }
    
    // PITFALL 2: Not handling errors
    noErrorHandling := func(w http.ResponseWriter, r *http.Request) {
        // ❌ What if this fails?
        json.NewEncoder(w).Encode(complexData)
        
        // ✅ Better:
        if err := json.NewEncoder(w).Encode(complexData); err != nil {
            http.Error(w, "Failed to encode response", http.StatusInternalServerError)
        }
    }
    
    // PITFALL 3: Forgetting Content-Type
    noContentType := func(w http.ResponseWriter, r *http.Request) {
        // ❌ Browser won't know this is JSON
        w.Write([]byte(`{"message": "hello"}`))
        
        // ✅ Better:
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"message": "hello"}`))
    }
    
    // PITFALL 4: Writing multiple status codes
    multipleStatusCodes := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)      // First one wins
        w.WriteHeader(http.StatusCreated) // Ignored!
    }
    
    // PITFALL 5: Not validating data before responding
    noValidation := func(w http.ResponseWriter, r *http.Request) {
        var user User
        json.NewDecoder(r.Body).Decode(&user)
        
        // ❌ What if user is invalid?
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(user)
        
        // ✅ Better: validate first
        if user.Name == "" || user.Email == "" {
            w.WriteHeader(http.StatusBadRequest)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Name and email are required",
            })
            return
        }
    }
}
```

### Helper Functions for Better Responses

```go
// Helper function for JSON responses
func WriteJSONResponse(w http.ResponseWriter, data interface{}, statusCode int) error {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    return json.NewEncoder(w).Encode(data)
}

// Helper function for error responses
func WriteErrorResponse(w http.ResponseWriter, statusCode int, message string) error {
    return WriteJSONResponse(w, map[string]interface{}{
        "success":   false,
        "error":     message,
        "timestamp": time.Now().Format(time.RFC3339),
    }, statusCode)
}

// Helper function for success responses
func WriteSuccessResponse(w http.ResponseWriter, data interface{}) error {
    return WriteJSONResponse(w, map[string]interface{}{
        "success": true,
        "data":    data,
    }, http.StatusOK)
}

// Usage example
func userHandler(w http.ResponseWriter, r *http.Request) {
    user, err := getUserByID(123)
    if err != nil {
        WriteErrorResponse(w, http.StatusNotFound, "User not found")
        return
    }
    
    WriteSuccessResponse(w, user)
}
```

## Key Takeaways

### Response Fundamentals
1. **HTTP Response Structure** - Status line, headers, body (in that order)
2. **ResponseWriter Interface** - Header(), WriteHeader(), Write() methods
3. **Order Matters** - Headers first, then status, then body
4. **Headers Lock** - After first write, headers cannot be changed

### Status Codes
1. **2xx Success** - 200 (OK), 201 (Created), 204 (No Content)
2. **4xx Client Error** - 400 (Bad Request), 404 (Not Found), 409 (Conflict)
3. **5xx Server Error** - 500 (Internal Error), 503 (Service Unavailable)
4. **Use Appropriately** - Match status code to actual situation

### Headers
1. **Content-Type** - Always specify the response format
2. **Custom Headers** - Use X- prefix for custom headers
3. **Security Headers** - Protect against common vulnerabilities
4. **API Headers** - Include versioning, rate limits, request IDs

### Response Body
1. **Multiple Formats** - JSON, HTML, CSV, XML based on client needs
2. **Error Handling** - Validate data before encoding
3. **Consistent Structure** - Use standard response formats
4. **Streaming** - For large responses, consider streaming

### Best Practices
1. **Validate Early** - Check input before processing
2. **Handle Errors** - Provide meaningful error messages
3. **Use Helpers** - Create utility functions for common responses
4. **Test Edge Cases** - Handle malformed requests gracefully

Understanding response writing is crucial for building reliable APIs that clients can depend on. Proper responses help clients understand what happened with their request and how to handle the result.
