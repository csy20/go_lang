# JSON Handling: Marshalling and Unmarshalling in Go

## Table of Contents
1. [What is JSON and Why Do We Need It?](#what-is-json-and-why-do-we-need-it)
2. [Understanding Marshalling vs Unmarshalling](#understanding-marshalling-vs-unmarshalling)
3. [The encoding/json Package](#the-encodingjson-package)
4. [Basic JSON Marshalling (Go to JSON)](#basic-json-marshalling-go-to-json)
5. [Basic JSON Unmarshalling (JSON to Go)](#basic-json-unmarshalling-json-to-go)
6. [Working with JSON Struct Tags](#working-with-json-struct-tags)
7. [Handling Different Data Types](#handling-different-data-types)
8. [Working with Nested Structures](#working-with-nested-structures)
9. [JSON and HTTP APIs](#json-and-http-apis)
10. [Advanced JSON Techniques](#advanced-json-techniques)
11. [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)
12. [Real-World Examples](#real-world-examples)

---

## What is JSON and Why Do We Need It?

### Understanding JSON Basics

JSON (JavaScript Object Notation) is a **text format** for storing and exchanging data:

```json
{
  "name": "John Doe",
  "age": 30,
  "email": "john@example.com",
  "active": true,
  "skills": ["Go", "Python", "JavaScript"],
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "zipcode": "10001"
  }
}
```

### Why JSON is Essential for APIs

```go
// Problem: How do we send Go data over HTTP?

type User struct {
    Name  string
    Age   int
    Email string
}

func sendUserData() {
    user := User{
        Name:  "John",
        Age:   30,
        Email: "john@example.com",
    }
    
    // Can't send Go struct directly over HTTP
    // HTTP only understands text/bytes
    
    // Solution: Convert to JSON (a text format)
    // Go struct → JSON text → HTTP → JSON text → Go struct
}
```

### The Data Flow

```go
// Complete data flow in web APIs:

func dataFlowExample() {
    // 1. Client side (maybe JavaScript):
    // JavaScript Object → JSON string → HTTP request
    
    // 2. Server side (Go):
    // HTTP request → JSON string → Go struct → Process → Go struct → JSON string → HTTP response
    
    // 3. Client side:
    // HTTP response → JSON string → JavaScript Object
}
```

---

## Understanding Marshalling vs Unmarshalling

### What Are These Terms?

```go
// Marshalling = Go data → JSON text
// Unmarshalling = JSON text → Go data

func marshallingVsUnmarshalling() {
    // MARSHALLING: Converting Go data to JSON
    user := User{Name: "John", Age: 30}
    // user (Go struct) → `{"name":"John","age":30}` (JSON string)
    
    // UNMARSHALLING: Converting JSON to Go data
    jsonData := `{"name":"John","age":30}`
    // jsonData (JSON string) → user (Go struct)
}

// Think of it like translation:
// Marshalling = translating from Go to JSON
// Unmarshalling = translating from JSON to Go
```

### Why These Names?

```go
// Historical context:
// "Marshal" = organize data for transmission
// "Unmarshal" = extract data from transmission

func analogyExample() {
    // Like packing and unpacking a suitcase:
    
    // MARSHALLING (packing):
    // Your clothes (Go data) → organized in suitcase (JSON format)
    
    // UNMARSHALLING (unpacking):
    // Organized suitcase (JSON format) → your clothes (Go data)
}
```

---

## The encoding/json Package

### Package Overview

```go
import "encoding/json"

// The encoding/json package provides:
// 1. json.Marshal() - Go to JSON
// 2. json.Unmarshal() - JSON to Go
// 3. json.NewEncoder() - streaming JSON encoding
// 4. json.NewDecoder() - streaming JSON decoding
```

### Basic Functions Signatures

```go
func packageFunctions() {
    // Marshal: Convert Go value to JSON bytes
    func Marshal(v interface{}) ([]byte, error)
    
    // Unmarshal: Convert JSON bytes to Go value
    func Unmarshal(data []byte, v interface{}) error
    
    // Notice:
    // 1. Marshal RETURNS the JSON data
    // 2. Unmarshal MODIFIES the provided variable (pointer required)
}
```

---

## Basic JSON Marshalling (Go to JSON)

### Simple Marshalling Example

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
)

type Person struct {
    Name  string
    Age   int
    Email string
}

func basicMarshalling() {
    // 1. Create Go data
    person := Person{
        Name:  "Alice Johnson",
        Age:   28,
        Email: "alice@example.com",
    }
    
    // 2. Convert to JSON
    jsonData, err := json.Marshal(person)
    if err != nil {
        log.Fatal("Error marshalling:", err)
    }
    
    // 3. jsonData is []byte, convert to string for display
    fmt.Println("JSON output:")
    fmt.Println(string(jsonData))
    
    // Output: {"Name":"Alice Johnson","Age":28,"Email":"alice@example.com"}
}
```

### How Marshalling Works Internally

```go
// Step-by-step breakdown of what json.Marshal() does:

func marshallingProcess() {
    person := Person{Name: "Alice", Age: 28, Email: "alice@example.com"}
    
    // Internally, json.Marshal():
    // 1. Examines the struct using reflection
    // 2. Iterates through each field
    // 3. Converts each field to JSON format:
    //    - string "Alice" → "Alice" (quoted)
    //    - int 28 → 28 (no quotes)
    //    - string "alice@example.com" → "alice@example.com" (quoted)
    // 4. Wraps in JSON object: {"Name":"Alice","Age":28,"Email":"alice@example.com"}
    // 5. Returns as []byte
    
    jsonData, _ := json.Marshal(person)
    fmt.Printf("Type: %T\n", jsonData)      // Type: []byte
    fmt.Printf("Value: %s\n", jsonData)     // Value: {"Name":"Alice","Age":28,"Email":"alice@example.com"}
}
```

### Marshalling Different Types

```go
func marshallingTypes() {
    // Basic types
    name := "John"
    age := 30
    active := true
    score := 98.5
    
    nameJSON, _ := json.Marshal(name)
    ageJSON, _ := json.Marshal(age)
    activeJSON, _ := json.Marshal(active)
    scoreJSON, _ := json.Marshal(score)
    
    fmt.Printf("String: %s\n", nameJSON)   // "John"
    fmt.Printf("Int: %s\n", ageJSON)       // 30
    fmt.Printf("Bool: %s\n", activeJSON)   // true
    fmt.Printf("Float: %s\n", scoreJSON)   // 98.5
    
    // Slices
    languages := []string{"Go", "Python", "JavaScript"}
    languagesJSON, _ := json.Marshal(languages)
    fmt.Printf("Slice: %s\n", languagesJSON) // ["Go","Python","JavaScript"]
    
    // Maps
    settings := map[string]interface{}{
        "theme":     "dark",
        "fontSize":  14,
        "autoSave":  true,
    }
    settingsJSON, _ := json.Marshal(settings)
    fmt.Printf("Map: %s\n", settingsJSON) // {"autoSave":true,"fontSize":14,"theme":"dark"}
}
```

---

## Basic JSON Unmarshalling (JSON to Go)

### Simple Unmarshalling Example

```go
func basicUnmarshalling() {
    // 1. Start with JSON data (usually from HTTP request, file, etc.)
    jsonData := `{
        "Name": "Bob Smith",
        "Age": 35,
        "Email": "bob@example.com"
    }`
    
    // 2. Create a variable to hold the result
    var person Person
    
    // 3. Unmarshal JSON into the Go struct
    err := json.Unmarshal([]byte(jsonData), &person)
    if err != nil {
        log.Fatal("Error unmarshalling:", err)
    }
    
    // 4. Now person contains the data from JSON
    fmt.Printf("Name: %s\n", person.Name)   // Name: Bob Smith
    fmt.Printf("Age: %d\n", person.Age)     // Age: 35
    fmt.Printf("Email: %s\n", person.Email) // Email: bob@example.com
}
```

### Why Do We Need a Pointer?

```go
func pointerExplanation() {
    jsonData := `{"Name":"Charlie","Age":25,"Email":"charlie@example.com"}`
    
    // ❌ Wrong - without pointer
    var person Person
    // json.Unmarshal([]byte(jsonData), person) // This won't work!
    
    // ✅ Correct - with pointer
    err := json.Unmarshal([]byte(jsonData), &person)
    
    // Why pointer is needed:
    // json.Unmarshal needs to MODIFY the variable
    // It can't modify a copy, it needs the actual memory location
    // That's what &person gives - the memory address
    
    if err == nil {
        fmt.Printf("Successfully unmarshalled: %+v\n", person)
    }
}
```

### How Unmarshalling Works Internally

```go
func unmarshallingProcess() {
    jsonData := `{"Name":"David","Age":40,"Email":"david@example.com"}`
    var person Person
    
    // Internally, json.Unmarshal():
    // 1. Parses the JSON string
    // 2. Examines the target struct (person) using reflection
    // 3. Maps JSON fields to struct fields:
    //    - JSON "Name" → struct field Name
    //    - JSON "Age" → struct field Age
    //    - JSON "Email" → struct field Email
    // 4. Converts JSON values to Go types:
    //    - "David" (JSON string) → "David" (Go string)
    //    - 40 (JSON number) → 40 (Go int)
    //    - "david@example.com" (JSON string) → "david@example.com" (Go string)
    // 5. Assigns values to struct fields
    
    json.Unmarshal([]byte(jsonData), &person)
    fmt.Printf("Result: %+v\n", person)
}
```

### Unmarshalling to Different Types

```go
func unmarshallingToTypes() {
    // Unmarshalling to basic types
    nameJSON := `"Emma"`
    var name string
    json.Unmarshal([]byte(nameJSON), &name)
    fmt.Printf("Name: %s\n", name) // Name: Emma
    
    ageJSON := `25`
    var age int
    json.Unmarshal([]byte(ageJSON), &age)
    fmt.Printf("Age: %d\n", age) // Age: 25
    
    // Unmarshalling to slices
    languagesJSON := `["Go", "Rust", "TypeScript"]`
    var languages []string
    json.Unmarshal([]byte(languagesJSON), &languages)
    fmt.Printf("Languages: %v\n", languages) // Languages: [Go Rust TypeScript]
    
    // Unmarshalling to maps
    configJSON := `{"host":"localhost","port":8080,"debug":true}`
    var config map[string]interface{}
    json.Unmarshal([]byte(configJSON), &config)
    fmt.Printf("Config: %v\n", config) // Config: map[debug:true host:localhost port:8080]
}
```

---

## Working with JSON Struct Tags

### What Are Struct Tags?

Struct tags are **metadata** attached to struct fields that control JSON behavior:

```go
type User struct {
    // Field name in JSON will be exactly "Name"
    Name string
    
    // Field name in JSON will be "email" (lowercase)
    Email string `json:"email"`
    
    // Field name in JSON will be "user_age"
    Age int `json:"user_age"`
    
    // This field will be ignored in JSON
    Password string `json:"-"`
    
    // This field will be omitted if empty
    Bio string `json:"bio,omitempty"`
}
```

### Basic Tag Examples

```go
func basicTagExamples() {
    type Product struct {
        ID          int     `json:"id"`
        Name        string  `json:"name"`
        Price       float64 `json:"price"`
        InStock     bool    `json:"in_stock"`
        Description string  `json:"description,omitempty"`
        Secret      string  `json:"-"`                    // Never included in JSON
    }
    
    product := Product{
        ID:      123,
        Name:    "Laptop",
        Price:   999.99,
        InStock: true,
        Secret:  "internal-data",
        // Description is empty, will be omitted due to "omitempty"
    }
    
    jsonData, _ := json.Marshal(product)
    fmt.Println(string(jsonData))
    // Output: {"id":123,"name":"Laptop","price":999.99,"in_stock":true}
    // Notice: "description" is omitted (empty + omitempty)
    // Notice: "Secret" is never included (json:"-")
}
```

### Tag Options Explained

```go
type TagExamples struct {
    // 1. Custom field name
    FirstName string `json:"first_name"`
    
    // 2. Omit if empty
    MiddleName string `json:"middle_name,omitempty"`
    
    // 3. Always omit from JSON
    InternalID string `json:"-"`
    
    // 4. Use field name as-is (no tag needed, but shown for clarity)
    LastName string `json:"LastName"`
    
    // 5. Multiple options
    Email string `json:"email_address,omitempty"`
    
    // 6. Keep field name but with options
    Age int `json:",omitempty"` // Empty tag name = use field name "Age"
}

func tagOptionsDemo() {
    example := TagExamples{
        FirstName:  "John",
        // MiddleName empty - will be omitted
        InternalID: "secret-123",
        LastName:   "Doe",
        Email:      "john@example.com",
        // Age: 0 (zero value) - will be omitted due to omitempty
    }
    
    jsonData, _ := json.Marshal(example)
    fmt.Println(string(jsonData))
    // Output: {"first_name":"John","LastName":"Doe","email_address":"john@example.com"}
}
```

### Understanding omitempty

```go
func omitemptyExplanation() {
    type Settings struct {
        Theme    string `json:"theme,omitempty"`
        FontSize int    `json:"font_size,omitempty"`
        AutoSave bool   `json:"auto_save,omitempty"`
        Tags     []string `json:"tags,omitempty"`
    }
    
    // Example 1: All fields have values
    settings1 := Settings{
        Theme:    "dark",
        FontSize: 14,
        AutoSave: true,
        Tags:     []string{"work", "personal"},
    }
    
    json1, _ := json.Marshal(settings1)
    fmt.Println("With values:", string(json1))
    // Output: {"theme":"dark","font_size":14,"auto_save":true,"tags":["work","personal"]}
    
    // Example 2: Some fields are "empty" (zero values)
    settings2 := Settings{
        Theme: "light",
        // FontSize: 0 (zero value for int)
        // AutoSave: false (zero value for bool)
        // Tags: nil (zero value for slice)
    }
    
    json2, _ := json.Marshal(settings2)
    fmt.Println("With empty values:", string(json2))
    // Output: {"theme":"light"}
    // FontSize, AutoSave, and Tags are omitted because they're "empty"
}
```

---

## Handling Different Data Types

### Pointers and Nil Values

```go
func handlingPointers() {
    type User struct {
        Name    string  `json:"name"`
        Age     *int    `json:"age,omitempty"`     // Pointer to int
        Email   *string `json:"email,omitempty"`   // Pointer to string
        Active  *bool   `json:"active,omitempty"`  // Pointer to bool
    }
    
    // Helper functions to create pointers
    intPtr := func(i int) *int { return &i }
    stringPtr := func(s string) *string { return &s }
    boolPtr := func(b bool) *bool { return &b }
    
    // User with all values
    user1 := User{
        Name:   "Alice",
        Age:    intPtr(30),
        Email:  stringPtr("alice@example.com"),
        Active: boolPtr(true),
    }
    
    json1, _ := json.Marshal(user1)
    fmt.Println("Full user:", string(json1))
    // Output: {"name":"Alice","age":30,"email":"alice@example.com","active":true}
    
    // User with some nil values
    user2 := User{
        Name: "Bob",
        Age:  intPtr(25),
        // Email and Active are nil, will be omitted
    }
    
    json2, _ := json.Marshal(user2)
    fmt.Println("Partial user:", string(json2))
    // Output: {"name":"Bob","age":25}
}
```

### Time Handling

```go
import "time"

func handlingTime() {
    type Event struct {
        Title     string    `json:"title"`
        StartTime time.Time `json:"start_time"`
        EndTime   time.Time `json:"end_time"`
    }
    
    event := Event{
        Title:     "Go Workshop",
        StartTime: time.Date(2024, 1, 15, 9, 0, 0, 0, time.UTC),
        EndTime:   time.Date(2024, 1, 15, 17, 0, 0, 0, time.UTC),
    }
    
    jsonData, _ := json.Marshal(event)
    fmt.Println("Event JSON:", string(jsonData))
    // Output: {"title":"Go Workshop","start_time":"2024-01-15T09:00:00Z","end_time":"2024-01-15T17:00:00Z"}
    
    // Unmarshalling time
    jsonInput := `{
        "title": "Meeting",
        "start_time": "2024-01-16T14:30:00Z",
        "end_time": "2024-01-16T15:30:00Z"
    }`
    
    var eventFromJSON Event
    json.Unmarshal([]byte(jsonInput), &eventFromJSON)
    fmt.Printf("Parsed event: %+v\n", eventFromJSON)
}
```

### Custom Types and Interfaces

```go
func handlingCustomTypes() {
    type Status int
    
    const (
        StatusInactive Status = 0
        StatusActive   Status = 1
        StatusPending  Status = 2
    )
    
    type User struct {
        Name   string `json:"name"`
        Status Status `json:"status"`
    }
    
    user := User{
        Name:   "Charlie",
        Status: StatusActive,
    }
    
    jsonData, _ := json.Marshal(user)
    fmt.Println("User with custom type:", string(jsonData))
    // Output: {"name":"Charlie","status":1}
    
    // interface{} fields
    type FlexibleData struct {
        Name  string      `json:"name"`
        Value interface{} `json:"value"`
    }
    
    data1 := FlexibleData{Name: "count", Value: 42}
    data2 := FlexibleData{Name: "message", Value: "hello"}
    data3 := FlexibleData{Name: "active", Value: true}
    
    json1, _ := json.Marshal(data1)
    json2, _ := json.Marshal(data2)
    json3, _ := json.Marshal(data3)
    
    fmt.Println("Flexible data 1:", string(json1)) // {"name":"count","value":42}
    fmt.Println("Flexible data 2:", string(json2)) // {"name":"message","value":"hello"}
    fmt.Println("Flexible data 3:", string(json3)) // {"name":"active","value":true}
}
```

---

## Working with Nested Structures

### Simple Nested Structures

```go
func simpleNestedStructures() {
    type Address struct {
        Street  string `json:"street"`
        City    string `json:"city"`
        Country string `json:"country"`
        ZipCode string `json:"zip_code"`
    }
    
    type Person struct {
        Name    string  `json:"name"`
        Age     int     `json:"age"`
        Address Address `json:"address"` // Nested struct
    }
    
    person := Person{
        Name: "Sarah Connor",
        Age:  35,
        Address: Address{
            Street:  "123 Tech Street",
            City:    "San Francisco",
            Country: "USA",
            ZipCode: "94105",
        },
    }
    
    jsonData, _ := json.Marshal(person)
    fmt.Println("Nested struct JSON:")
    fmt.Println(string(jsonData))
    
    // Pretty-printed version for readability:
    prettyJSON, _ := json.MarshalIndent(person, "", "  ")
    fmt.Println("Pretty JSON:")
    fmt.Println(string(prettyJSON))
}

// Output:
// {
//   "name": "Sarah Connor",
//   "age": 35,
//   "address": {
//     "street": "123 Tech Street",
//     "city": "San Francisco",
//     "country": "USA",
//     "zip_code": "94105"
//   }
// }
```

### Complex Nested Structures

```go
func complexNestedStructures() {
    type Tag struct {
        Name  string `json:"name"`
        Color string `json:"color"`
    }
    
    type Comment struct {
        ID      int    `json:"id"`
        Author  string `json:"author"`
        Content string `json:"content"`
    }
    
    type Post struct {
        ID       int       `json:"id"`
        Title    string    `json:"title"`
        Content  string    `json:"content"`
        Author   string    `json:"author"`
        Tags     []Tag     `json:"tags"`        // Slice of structs
        Comments []Comment `json:"comments"`    // Slice of structs
    }
    
    post := Post{
        ID:      1,
        Title:   "Introduction to Go JSON",
        Content: "JSON handling in Go is powerful...",
        Author:  "Go Developer",
        Tags: []Tag{
            {Name: "golang", Color: "blue"},
            {Name: "json", Color: "green"},
            {Name: "tutorial", Color: "orange"},
        },
        Comments: []Comment{
            {ID: 1, Author: "Reader1", Content: "Great tutorial!"},
            {ID: 2, Author: "Reader2", Content: "Very helpful, thanks!"},
        },
    }
    
    jsonData, _ := json.MarshalIndent(post, "", "  ")
    fmt.Println("Complex nested structure:")
    fmt.Println(string(jsonData))
    
    // Unmarshalling back
    var postFromJSON Post
    json.Unmarshal(jsonData, &postFromJSON)
    
    fmt.Printf("Unmarshalled post has %d tags and %d comments\n", 
        len(postFromJSON.Tags), len(postFromJSON.Comments))
}
```

### Handling Deeply Nested JSON

```go
func deeplyNestedJSON() {
    // Sometimes you receive deeply nested JSON from APIs
    jsonData := `{
        "user": {
            "profile": {
                "personal": {
                    "name": "John Doe",
                    "contact": {
                        "email": "john@example.com",
                        "phone": {
                            "country_code": "+1",
                            "number": "555-0123"
                        }
                    }
                }
            }
        }
    }`
    
    // Option 1: Define complete struct hierarchy
    type Phone struct {
        CountryCode string `json:"country_code"`
        Number      string `json:"number"`
    }
    
    type Contact struct {
        Email string `json:"email"`
        Phone Phone  `json:"phone"`
    }
    
    type Personal struct {
        Name    string  `json:"name"`
        Contact Contact `json:"contact"`
    }
    
    type Profile struct {
        Personal Personal `json:"personal"`
    }
    
    type UserWrapper struct {
        User struct {
            Profile Profile `json:"profile"`
        } `json:"user"`
    }
    
    var data UserWrapper
    json.Unmarshal([]byte(jsonData), &data)
    
    // Access deeply nested data
    name := data.User.Profile.Personal.Name
    email := data.User.Profile.Personal.Contact.Email
    phone := data.User.Profile.Personal.Contact.Phone.Number
    
    fmt.Printf("Name: %s, Email: %s, Phone: %s\n", name, email, phone)
    
    // Option 2: Use map[string]interface{} for flexible parsing
    var flexibleData map[string]interface{}
    json.Unmarshal([]byte(jsonData), &flexibleData)
    
    // Navigate through the map (requires type assertions)
    user := flexibleData["user"].(map[string]interface{})
    profile := user["profile"].(map[string]interface{})
    personal := profile["personal"].(map[string]interface{})
    flexName := personal["name"].(string)
    
    fmt.Printf("Flexible parsing - Name: %s\n", flexName)
}
```

---

## JSON and HTTP APIs

### Sending JSON in HTTP Responses

```go
import (
    "encoding/json"
    "net/http"
)

func sendingJSONResponses() {
    type User struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    
    // Handler that sends JSON response
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        users := []User{
            {ID: 1, Name: "Alice", Email: "alice@example.com"},
            {ID: 2, Name: "Bob", Email: "bob@example.com"},
        }
        
        // Set content type BEFORE writing data
        w.Header().Set("Content-Type", "application/json")
        
        // Method 1: json.Marshal + w.Write
        jsonData, err := json.Marshal(users)
        if err != nil {
            http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
            return
        }
        w.Write(jsonData)
    })
    
    // Alternative: Using json.NewEncoder for streaming
    http.HandleFunc("/users-stream", func(w http.ResponseWriter, r *http.Request) {
        users := []User{
            {ID: 1, Name: "Charlie", Email: "charlie@example.com"},
        }
        
        w.Header().Set("Content-Type", "application/json")
        
        // Method 2: json.NewEncoder (more efficient for large data)
        encoder := json.NewEncoder(w)
        if err := encoder.Encode(users); err != nil {
            http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
        }
    })
}
```

### Receiving JSON in HTTP Requests

```go
func receivingJSONRequests() {
    type CreateUserRequest struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    
    type CreateUserResponse struct {
        ID      int    `json:"id"`
        Message string `json:"message"`
    }
    
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != "POST" {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        
        // Check content type
        if r.Header.Get("Content-Type") != "application/json" {
            http.Error(w, "Content-Type must be application/json", http.StatusBadRequest)
            return
        }
        
        var req CreateUserRequest
        
        // Method 1: json.NewDecoder (recommended for HTTP)
        decoder := json.NewDecoder(r.Body)
        if err := decoder.Decode(&req); err != nil {
            http.Error(w, "Invalid JSON", http.StatusBadRequest)
            return
        }
        
        // Validate required fields
        if req.Name == "" || req.Email == "" {
            http.Error(w, "Name and email are required", http.StatusBadRequest)
            return
        }
        
        // Process the request (create user in database, etc.)
        newUserID := 123 // This would come from your database
        
        // Send JSON response
        response := CreateUserResponse{
            ID:      newUserID,
            Message: "User created successfully",
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(response)
    })
    
    // Alternative method using io.ReadAll
    http.HandleFunc("/users-alt", func(w http.ResponseWriter, r *http.Request) {
        if r.Method != "POST" {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        
        // Method 2: Read all then unmarshal
        body, err := io.ReadAll(r.Body)
        if err != nil {
            http.Error(w, "Error reading request body", http.StatusBadRequest)
            return
        }
        defer r.Body.Close()
        
        var req CreateUserRequest
        if err := json.Unmarshal(body, &req); err != nil {
            http.Error(w, "Invalid JSON", http.StatusBadRequest)
            return
        }
        
        // Process request...
        fmt.Fprintf(w, "Received user: %s (%s)", req.Name, req.Email)
    })
}
```

### Complete API Example

```go
func completeAPIExample() {
    type User struct {
        ID        int       `json:"id"`
        Name      string    `json:"name"`
        Email     string    `json:"email"`
        CreatedAt time.Time `json:"created_at"`
    }
    
    type ErrorResponse struct {
        Error   string `json:"error"`
        Code    int    `json:"code"`
        Message string `json:"message"`
    }
    
    // In-memory storage (in real app, use database)
    var users []User
    var nextID = 1
    
    // Helper function to send JSON error
    sendError := func(w http.ResponseWriter, message string, code int) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(ErrorResponse{
            Error:   "API Error",
            Code:    code,
            Message: message,
        })
    }
    
    // Helper function to send JSON success
    sendJSON := func(w http.ResponseWriter, data interface{}, code int) {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(data)
    }
    
    // GET /users - List all users
    http.HandleFunc("/users", func(w http.ResponseWriter, r *http.Request) {
        if r.Method == "GET" {
            sendJSON(w, users, http.StatusOK)
            return
        }
        
        if r.Method == "POST" {
            var newUser User
            if err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {
                sendError(w, "Invalid JSON format", http.StatusBadRequest)
                return
            }
            
            // Validate
            if newUser.Name == "" || newUser.Email == "" {
                sendError(w, "Name and email are required", http.StatusBadRequest)
                return
            }
            
            // Create user
            newUser.ID = nextID
            nextID++
            newUser.CreatedAt = time.Now()
            users = append(users, newUser)
            
            sendJSON(w, newUser, http.StatusCreated)
            return
        }
        
        sendError(w, "Method not allowed", http.StatusMethodNotAllowed)
    })
    
    fmt.Println("API server starting on :8080")
    http.ListenAndServe(":8080", nil)
}
```

---

## Advanced JSON Techniques

### Custom JSON Marshalling

```go
import "fmt"

// Custom marshalling by implementing json.Marshaler interface
type Color struct {
    R, G, B int
}

// MarshalJSON implements json.Marshaler interface
func (c Color) MarshalJSON() ([]byte, error) {
    // Custom format: "#RRGGBB" instead of {"R":255,"G":0,"B":0}
    hex := fmt.Sprintf("#%02X%02X%02X", c.R, c.G, c.B)
    return json.Marshal(hex) // Marshal the string
}

// UnmarshalJSON implements json.Unmarshaler interface
func (c *Color) UnmarshalJSON(data []byte) error {
    var hex string
    if err := json.Unmarshal(data, &hex); err != nil {
        return err
    }
    
    // Parse hex color
    if len(hex) != 7 || hex[0] != '#' {
        return fmt.Errorf("invalid color format: %s", hex)
    }
    
    _, err := fmt.Sscanf(hex, "#%02X%02X%02X", &c.R, &c.G, &c.B)
    return err
}

func customMarshallingExample() {
    type Theme struct {
        Name       string `json:"name"`
        Background Color  `json:"background"`
        Foreground Color  `json:"foreground"`
    }
    
    theme := Theme{
        Name:       "Dark Theme",
        Background: Color{R: 33, G: 37, B: 43},    // Dark gray
        Foreground: Color{R: 255, G: 255, B: 255}, // White
    }
    
    jsonData, _ := json.MarshalIndent(theme, "", "  ")
    fmt.Println("Custom marshalling:")
    fmt.Println(string(jsonData))
    
    // Output:
    // {
    //   "name": "Dark Theme",
    //   "background": "#21252B",
    //   "foreground": "#FFFFFF"
    // }
    
    // Unmarshalling back
    var themeFromJSON Theme
    json.Unmarshal(jsonData, &themeFromJSON)
    fmt.Printf("Unmarshalled: %+v\n", themeFromJSON)
}
```

### Working with Raw JSON

```go
import "encoding/json"

func rawJSONExample() {
    // Sometimes you want to defer parsing of part of JSON
    type PartialMessage struct {
        Type string          `json:"type"`
        Data json.RawMessage `json:"data"` // Raw JSON, not parsed yet
    }
    
    // Different message types
    type UserMessage struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    
    type OrderMessage struct {
        ID    int     `json:"id"`
        Total float64 `json:"total"`
    }
    
    // Example JSON messages
    messages := []string{
        `{"type":"user","data":{"name":"Alice","email":"alice@example.com"}}`,
        `{"type":"order","data":{"id":123,"total":99.99}}`,
    }
    
    for _, msgJSON := range messages {
        var partial PartialMessage
        json.Unmarshal([]byte(msgJSON), &partial)
        
        fmt.Printf("Message type: %s\n", partial.Type)
        
        // Now parse the data based on type
        switch partial.Type {
        case "user":
            var user UserMessage
            json.Unmarshal(partial.Data, &user)
            fmt.Printf("User: %s (%s)\n", user.Name, user.Email)
            
        case "order":
            var order OrderMessage
            json.Unmarshal(partial.Data, &order)
            fmt.Printf("Order: #%d, Total: $%.2f\n", order.ID, order.Total)
        }
    }
}
```

### Handling Unknown Fields

```go
func unknownFieldsExample() {
    // Sometimes JSON has extra fields you don't know about
    type KnownUser struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    
    // JSON with extra fields
    jsonData := `{
        "name": "John Doe",
        "email": "john@example.com",
        "age": 30,
        "department": "Engineering",
        "start_date": "2023-01-15"
    }`
    
    // Method 1: Parse only known fields (extra fields ignored)
    var knownUser KnownUser
    json.Unmarshal([]byte(jsonData), &knownUser)
    fmt.Printf("Known fields only: %+v\n", knownUser)
    
    // Method 2: Capture all fields using map
    var allFields map[string]interface{}
    json.Unmarshal([]byte(jsonData), &allFields)
    fmt.Printf("All fields: %+v\n", allFields)
    
    // Method 3: Combination - known fields + extra fields
    type FlexibleUser struct {
        Name   string                 `json:"name"`
        Email  string                 `json:"email"`
        Extras map[string]interface{} `json:"-"` // Will be populated manually
    }
    
    var flexUser FlexibleUser
    var temp map[string]interface{}
    json.Unmarshal([]byte(jsonData), &temp)
    
    // Extract known fields
    if name, ok := temp["name"].(string); ok {
        flexUser.Name = name
        delete(temp, "name")
    }
    if email, ok := temp["email"].(string); ok {
        flexUser.Email = email
        delete(temp, "email")
    }
    
    // Store remaining fields as extras
    flexUser.Extras = temp
    
    fmt.Printf("Flexible user: %+v\n", flexUser)
    fmt.Printf("Extra fields: %+v\n", flexUser.Extras)
}
```

---

## Common Pitfalls and Solutions

### Problem 1: Forgetting Pointer for Unmarshal

```go
func unmarshalPointerPitfall() {
    jsonData := `{"name":"John","age":30}`
    
    type Person struct {
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
    
    var person Person
    
    // ❌ WRONG - no pointer
    // err := json.Unmarshal([]byte(jsonData), person)
    // This won't work because Unmarshal can't modify the copy
    
    // ✅ CORRECT - with pointer
    err := json.Unmarshal([]byte(jsonData), &person)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
    } else {
        fmt.Printf("Success: %+v\n", person)
    }
}
```

### Problem 2: Case Sensitivity

```go
func caseSensitivityPitfall() {
    type User struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    
    // JSON with different casing
    jsonData1 := `{"name":"Alice","email":"alice@example.com"}` // matches
    jsonData2 := `{"Name":"Bob","Email":"bob@example.com"}`     // doesn't match tags
    jsonData3 := `{"NAME":"Charlie","EMAIL":"charlie@example.com"}` // doesn't match
    
    var user1, user2, user3 User
    
    json.Unmarshal([]byte(jsonData1), &user1)
    json.Unmarshal([]byte(jsonData2), &user2)
    json.Unmarshal([]byte(jsonData3), &user3)
    
    fmt.Printf("Lowercase JSON: %+v\n", user1) // Works: {Name:Alice Email:alice@example.com}
    fmt.Printf("Pascal JSON: %+v\n", user2)    // Partial: {Name: Email:}
    fmt.Printf("Uppercase JSON: %+v\n", user3) // Empty: {Name: Email:}
    
    // Solution: Use correct JSON tags
    type FlexibleUser struct {
        Name  string `json:"name"`        // matches "name"
        Email string `json:"email"`       // matches "email"
    }
    
    // Or for Go exported field names without tags:
    type GoStyleUser struct {
        Name  string // Can match "Name" or "name" (Go is flexible here)
        Email string // Can match "Email" or "email"
    }
    
    var goUser GoStyleUser
    json.Unmarshal([]byte(jsonData2), &goUser) // This works with Pascal case
    fmt.Printf("Go style: %+v\n", goUser)
}
```

### Problem 3: Type Mismatches

```go
func typeMismatchPitfall() {
    type Config struct {
        Port    int    `json:"port"`
        Enabled bool   `json:"enabled"`
        Timeout float64 `json:"timeout"`
    }
    
    // JSON with wrong types
    badJSON := `{
        "port": "8080",
        "enabled": "true", 
        "timeout": "30.5"
    }`
    
    var config Config
    err := json.Unmarshal([]byte(badJSON), &config)
    if err != nil {
        fmt.Printf("Type mismatch error: %v\n", err)
    }
    
    // Solution 1: Use correct JSON types
    goodJSON := `{
        "port": 8080,
        "enabled": true,
        "timeout": 30.5
    }`
    
    json.Unmarshal([]byte(goodJSON), &config)
    fmt.Printf("Correct types: %+v\n", config)
    
    // Solution 2: Use string fields and convert manually
    type FlexibleConfig struct {
        Port    string `json:"port"`
        Enabled string `json:"enabled"`
        Timeout string `json:"timeout"`
    }
    
    var flexConfig FlexibleConfig
    json.Unmarshal([]byte(badJSON), &flexConfig)
    
    // Convert manually
    port, _ := strconv.Atoi(flexConfig.Port)
    enabled := flexConfig.Enabled == "true"
    timeout, _ := strconv.ParseFloat(flexConfig.Timeout, 64)
    
    finalConfig := Config{
        Port:    port,
        Enabled: enabled,
        Timeout: timeout,
    }
    
    fmt.Printf("Manually converted: %+v\n", finalConfig)
}
```

### Problem 4: Empty Values vs Null

```go
func nullVsEmptyPitfall() {
    type User struct {
        Name    string  `json:"name"`
        Age     *int    `json:"age"`     // Pointer to handle null
        Email   string  `json:"email"`
        Active  *bool   `json:"active"`  // Pointer to handle null
    }
    
    // Different JSON scenarios
    jsons := []string{
        `{"name":"Alice","age":30,"email":"alice@example.com","active":true}`,
        `{"name":"Bob","age":null,"email":"","active":false}`,
        `{"name":"Charlie","email":"charlie@example.com"}`, // Missing fields
    }
    
    for i, jsonData := range jsons {
        var user User
        json.Unmarshal([]byte(jsonData), &user)
        
        fmt.Printf("User %d: %+v\n", i+1, user)
        
        // Check for null vs zero values
        if user.Age != nil {
            fmt.Printf("  Age is %d\n", *user.Age)
        } else {
            fmt.Printf("  Age is null\n")
        }
        
        if user.Active != nil {
            fmt.Printf("  Active is %t\n", *user.Active)
        } else {
            fmt.Printf("  Active is null\n")
        }
        
        fmt.Println()
    }
}
```

---

## Real-World Examples

### Example 1: REST API with JSON

```go
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "strings"
    "time"
)

type Book struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Author      string    `json:"author"`
    ISBN        string    `json:"isbn"`
    Price       float64   `json:"price"`
    InStock     bool      `json:"in_stock"`
    PublishedAt time.Time `json:"published_at"`
    Tags        []string  `json:"tags,omitempty"`
}

type BookRequest struct {
    Title       string    `json:"title"`
    Author      string    `json:"author"`
    ISBN        string    `json:"isbn"`
    Price       float64   `json:"price"`
    PublishedAt time.Time `json:"published_at"`
    Tags        []string  `json:"tags,omitempty"`
}

type APIResponse struct {
    Success bool        `json:"success"`
    Message string      `json:"message,omitempty"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}

// In-memory storage
var books []Book
var nextID = 1

func main() {
    // Initialize with sample data
    books = []Book{
        {
            ID:          1,
            Title:       "The Go Programming Language",
            Author:      "Alan Donovan",
            ISBN:        "978-0134190440",
            Price:       39.99,
            InStock:     true,
            PublishedAt: time.Date(2015, 10, 26, 0, 0, 0, 0, time.UTC),
            Tags:        []string{"programming", "go", "computer-science"},
        },
    }
    nextID = 2
    
    http.HandleFunc("/books", booksHandler)
    http.HandleFunc("/books/", bookHandler)
    
    fmt.Println("Book API server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}

func sendJSON(w http.ResponseWriter, response APIResponse, statusCode int) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(response)
}

func booksHandler(w http.ResponseWriter, r *http.Request) {
    switch r.Method {
    case "GET":
        // List all books
        sendJSON(w, APIResponse{
            Success: true,
            Data:    books,
        }, http.StatusOK)
        
    case "POST":
        // Create new book
        var req BookRequest
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            sendJSON(w, APIResponse{
                Success: false,
                Error:   "Invalid JSON format",
            }, http.StatusBadRequest)
            return
        }
        
        // Validate required fields
        if req.Title == "" || req.Author == "" {
            sendJSON(w, APIResponse{
                Success: false,
                Error:   "Title and author are required",
            }, http.StatusBadRequest)
            return
        }
        
        // Create new book
        book := Book{
            ID:          nextID,
            Title:       req.Title,
            Author:      req.Author,
            ISBN:        req.ISBN,
            Price:       req.Price,
            InStock:     true,
            PublishedAt: req.PublishedAt,
            Tags:        req.Tags,
        }
        
        books = append(books, book)
        nextID++
        
        sendJSON(w, APIResponse{
            Success: true,
            Message: "Book created successfully",
            Data:    book,
        }, http.StatusCreated)
        
    default:
        sendJSON(w, APIResponse{
            Success: false,
            Error:   "Method not allowed",
        }, http.StatusMethodNotAllowed)
    }
}

func bookHandler(w http.ResponseWriter, r *http.Request) {
    // Extract book ID from URL
    path := strings.TrimPrefix(r.URL.Path, "/books/")
    id, err := strconv.Atoi(path)
    if err != nil {
        sendJSON(w, APIResponse{
            Success: false,
            Error:   "Invalid book ID",
        }, http.StatusBadRequest)
        return
    }
    
    // Find book
    var book *Book
    var index int
    for i, b := range books {
        if b.ID == id {
            book = &b
            index = i
            break
        }
    }
    
    if book == nil {
        sendJSON(w, APIResponse{
            Success: false,
            Error:   "Book not found",
        }, http.StatusNotFound)
        return
    }
    
    switch r.Method {
    case "GET":
        // Get single book
        sendJSON(w, APIResponse{
            Success: true,
            Data:    book,
        }, http.StatusOK)
        
    case "PUT":
        // Update book
        var req BookRequest
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            sendJSON(w, APIResponse{
                Success: false,
                Error:   "Invalid JSON format",
            }, http.StatusBadRequest)
            return
        }
        
        // Update fields
        if req.Title != "" {
            books[index].Title = req.Title
        }
        if req.Author != "" {
            books[index].Author = req.Author
        }
        if req.ISBN != "" {
            books[index].ISBN = req.ISBN
        }
        if req.Price > 0 {
            books[index].Price = req.Price
        }
        if !req.PublishedAt.IsZero() {
            books[index].PublishedAt = req.PublishedAt
        }
        if req.Tags != nil {
            books[index].Tags = req.Tags
        }
        
        sendJSON(w, APIResponse{
            Success: true,
            Message: "Book updated successfully",
            Data:    books[index],
        }, http.StatusOK)
        
    case "DELETE":
        // Delete book
        books = append(books[:index], books[index+1:]...)
        
        sendJSON(w, APIResponse{
            Success: true,
            Message: "Book deleted successfully",
        }, http.StatusOK)
        
    default:
        sendJSON(w, APIResponse{
            Success: false,
            Error:   "Method not allowed",
        }, http.StatusMethodNotAllowed)
    }
}
```

### Example 2: Configuration File Handling

```go
func configurationExample() {
    type DatabaseConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Username string `json:"username"`
        Password string `json:"password"`
        Database string `json:"database"`
        SSLMode  string `json:"ssl_mode"`
    }
    
    type ServerConfig struct {
        Port         int           `json:"port"`
        Host         string        `json:"host"`
        ReadTimeout  time.Duration `json:"read_timeout"`
        WriteTimeout time.Duration `json:"write_timeout"`
    }
    
    type LoggingConfig struct {
        Level  string `json:"level"`
        Format string `json:"format"`
        Output string `json:"output"`
    }
    
    type AppConfig struct {
        Environment string          `json:"environment"`
        Debug       bool            `json:"debug"`
        Database    DatabaseConfig  `json:"database"`
        Server      ServerConfig    `json:"server"`
        Logging     LoggingConfig   `json:"logging"`
        Features    map[string]bool `json:"features"`
    }
    
    // Sample configuration
    config := AppConfig{
        Environment: "development",
        Debug:       true,
        Database: DatabaseConfig{
            Host:     "localhost",
            Port:     5432,
            Username: "app_user",
            Password: "secret_password",
            Database: "app_db",
            SSLMode:  "disable",
        },
        Server: ServerConfig{
            Port:         8080,
            Host:         "0.0.0.0",
            ReadTimeout:  30 * time.Second,
            WriteTimeout: 30 * time.Second,
        },
        Logging: LoggingConfig{
            Level:  "debug",
            Format: "json",
            Output: "stdout",
        },
        Features: map[string]bool{
            "user_registration": true,
            "email_verification": true,
            "social_login":      false,
        },
    }
    
    // Save configuration to JSON file
    configJSON, _ := json.MarshalIndent(config, "", "  ")
    fmt.Println("Configuration JSON:")
    fmt.Println(string(configJSON))
    
    // In a real app, you'd save to file:
    // os.WriteFile("config.json", configJSON, 0644)
    
    // Load configuration from JSON
    var loadedConfig AppConfig
    json.Unmarshal(configJSON, &loadedConfig)
    
    fmt.Printf("\nLoaded config - Environment: %s\n", loadedConfig.Environment)
    fmt.Printf("Database Host: %s:%d\n", loadedConfig.Database.Host, loadedConfig.Database.Port)
    fmt.Printf("Server will run on %s:%d\n", loadedConfig.Server.Host, loadedConfig.Server.Port)
}
```

## Key Takeaways

### JSON Fundamentals
1. **JSON is Text** - A standardized format for data exchange
2. **Marshalling** - Go data → JSON text (`json.Marshal`)
3. **Unmarshalling** - JSON text → Go data (`json.Unmarshal`)
4. **Always use pointers** for unmarshalling to allow modification

### Struct Tags
1. **Field Naming** - `json:"field_name"` controls JSON field names
2. **Omit Empty** - `json:",omitempty"` skips zero values
3. **Ignore Fields** - `json:"-"` excludes fields from JSON
4. **Case Matters** - JSON field names are case-sensitive

### HTTP APIs
1. **Content-Type** - Always set `application/json` header
2. **Error Handling** - Validate JSON format and required fields
3. **Streaming** - Use `json.NewEncoder/Decoder` for HTTP
4. **Consistent Responses** - Standardize your API response format

### Best Practices
1. **Validate Input** - Check required fields and data types
2. **Handle Errors** - Provide meaningful error messages
3. **Use Pointers** - For optional fields that can be null
4. **Custom Marshalling** - Implement `json.Marshaler` for special formats

JSON handling is fundamental to building modern web APIs in Go. Master these concepts and you'll be able to build robust, well-structured APIs that communicate effectively with other systems!