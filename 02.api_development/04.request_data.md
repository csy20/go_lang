# Reading Request Data: Understanding HTTP Data Flow

## Table of Contents
1. [What is Request Data?](#what-is-request-data)
2. [How HTTP Sends Data](#how-http-sends-data)
3. [Understanding Query Parameters](#understanding-query-parameters)
4. [Understanding Form Data](#understanding-form-data)
5. [Understanding Request Body](#understanding-request-body)
6. [Parsing Query Parameters](#parsing-query-parameters)
7. [Parsing Form Data](#parsing-form-data)
8. [Reading Request Body](#reading-request-body)
9. [Complete Request Data Examples](#complete-request-data-examples)
10. [Data Validation and Error Handling](#data-validation-and-error-handling)

---

## What is Request Data?

### Basic Concept

**Request data** is information that clients (browsers, mobile apps, other services) send to your server along with HTTP requests. Think of it like filling out a form or sending a letter - you need to include the information the recipient needs.

### Where Request Data Lives

```
HTTP Request Components:
┌─────────────────────────────────────────┐
│ REQUEST LINE: GET /search?q=golang HTTP/1.1 │ ← Query parameters here
├─────────────────────────────────────────┤
│ HEADERS:                                │
│   Content-Type: application/json        │ ← Data format info
│   Content-Length: 45                    │ ← Body size info
├─────────────────────────────────────────┤
│ BODY:                                   │ ← Form data or JSON here
│   {"name": "John", "age": 30}           │
└─────────────────────────────────────────┘
```

### Types of Request Data

```go
// 1. Query Parameters (in URL)
// GET /users?name=john&age=25&active=true
// Data: name="john", age="25", active="true"

// 2. Form Data (in request body)
// POST /users
// Content-Type: application/x-www-form-urlencoded
// Body: name=john&age=25&active=true

// 3. JSON Data (in request body)
// POST /users
// Content-Type: application/json
// Body: {"name": "john", "age": 25, "active": true}

// 4. Multipart Form Data (for file uploads)
// POST /upload
// Content-Type: multipart/form-data
// Body: [binary form data with files and fields]
```

### Real-World Data Flow

```
User Action                    HTTP Request                    Server Receives
    │                             │                              │
    │  Fills form:                │                              │
    │  Name: "John"               │  POST /register              │  r.FormValue("name") = "John"
    │  Email: "john@email.com"    │  Content-Type: form-data     │  r.FormValue("email") = "john@email.com"
    │  Age: 25                    │  Body: name=John&email=...   │  r.FormValue("age") = "25"
    │                             │                              │
    │  Clicks "Search"            │  GET /search?q=golang        │  r.URL.Query().Get("q") = "golang"
    │  in search box              │                              │
```

---

## How HTTP Sends Data

### Understanding HTTP Request Structure

```go
// This is what an HTTP request looks like on the wire:
func explainHTTPRequest() {
    example := `
    POST /api/users HTTP/1.1                    ← Request line
    Host: example.com                           ← Headers start
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 29                          ← Headers end
                                                ← Empty line separates headers from body
    name=John&email=john%40example.com          ← Body starts here
    `
    
    fmt.Println("Raw HTTP request:", example)
}
```

### How Go Parses This

```go
// Go automatically parses the HTTP request into an http.Request struct:
func showParsedRequest(r *http.Request) {
    // Request line becomes:
    fmt.Printf("Method: %s\n", r.Method)           // "POST"
    fmt.Printf("URL Path: %s\n", r.URL.Path)       // "/api/users"
    fmt.Printf("Protocol: %s\n", r.Proto)          // "HTTP/1.1"
    
    // Headers become:
    contentType := r.Header.Get("Content-Type")    // "application/x-www-form-urlencoded"
    contentLength := r.Header.Get("Content-Length") // "29"
    
    // Body becomes:
    body, _ := io.ReadAll(r.Body)                  // "name=John&email=john%40example.com"
    
    // But Go provides helper methods to parse the body further!
}
```

### URL Encoding Explained

```go
// URLs can only contain certain characters, so special characters are encoded:
func explainURLEncoding() {
    examples := map[string]string{
        "john@example.com": "john%40example.com",  // @ becomes %40
        "hello world":      "hello+world",         // space becomes +
        "50% off":          "50%25+off",          // % becomes %25
        "a=b&c=d":          "a%3Db%26c%3Dd",      // = becomes %3D, & becomes %26
    }
    
    for original, encoded := range examples {
        fmt.Printf("%s → %s\n", original, encoded)
    }
}

// Go automatically handles this encoding/decoding for you!
```

---

## Understanding Query Parameters

### What Are Query Parameters?

Query parameters are **key-value pairs** attached to the URL after a `?` character, separated by `&`:

```
URL Structure:
https://example.com/search?q=golang&category=tutorial&limit=10
                     │      │       │                  │
                     │      │       │                  └── Parameter 3: limit=10
                     │      │       └────────────────────── Parameter 2: category=tutorial
                     │      └────────────────────────────── Parameter 1: q=golang
                     └───────────────────────────────────── Query parameters start here
```

### How Query Parameters Work

```go
// When someone visits: http://localhost:8080/search?name=john&age=25&active=true

func queryExampleHandler(w http.ResponseWriter, r *http.Request) {
    // Go parses the URL and extracts query parameters
    fmt.Printf("Full URL: %s\n", r.URL.String())
    // Output: Full URL: /search?name=john&age=25&active=true
    
    fmt.Printf("Path only: %s\n", r.URL.Path)
    // Output: Path only: /search
    
    fmt.Printf("Query string: %s\n", r.URL.RawQuery)
    // Output: Query string: name=john&age=25&active=true
    
    // Get parsed query parameters
    queryParams := r.URL.Query()
    fmt.Printf("Parsed params: %v\n", queryParams)
    // Output: Parsed params: map[active:[true] age:[25] name:[john]]
}
```

### Query Parameter Characteristics

```go
func queryCharacteristics(w http.ResponseWriter, r *http.Request) {
    // 1. Always strings (even numbers)
    age := r.URL.Query().Get("age")
    fmt.Printf("Age type: %T, value: %s\n", age, age)
    // Output: Age type: string, value: 25
    
    // 2. Can have multiple values for same key
    // URL: /search?tag=go&tag=programming&tag=tutorial
    tags := r.URL.Query()["tag"]
    fmt.Printf("Tags: %v\n", tags)
    // Output: Tags: [go programming tutorial]
    
    // 3. Missing parameters return empty string
    missing := r.URL.Query().Get("nonexistent")
    fmt.Printf("Missing param: '%s'\n", missing)
    // Output: Missing param: ''
    
    // 4. Empty values are valid
    // URL: /search?name=&age=25
    name := r.URL.Query().Get("name")
    fmt.Printf("Empty name: '%s'\n", name)
    // Output: Empty name: ''
}
```

---

## Understanding Form Data

### What is Form Data?

Form data is information sent in the **request body** when users submit HTML forms or when applications send structured data to your server.

### HTML Form Example

```html
<!-- This HTML form: -->
<form action="/submit" method="POST">
    <input type="text" name="username" value="john">
    <input type="email" name="email" value="john@example.com">
    <input type="number" name="age" value="25">
    <input type="hidden" name="csrf_token" value="abc123">
    <button type="submit">Submit</button>
</form>

<!-- Generates this HTTP request: -->
POST /submit HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 58

username=john&email=john%40example.com&age=25&csrf_token=abc123
```

### Form Data vs Query Parameters

```go
func compareDataSources(w http.ResponseWriter, r *http.Request) {
    // URL: /submit?source=web&utm=campaign123
    // Body: username=john&email=john@example.com
    
    // Query parameters (from URL)
    source := r.URL.Query().Get("source")         // "web"
    utm := r.URL.Query().Get("utm")               // "campaign123"
    
    // Form data (from request body)
    username := r.FormValue("username")           // "john"
    email := r.FormValue("email")                 // "john@example.com"
    
    fmt.Printf("Source: %s (from query)\n", source)
    fmt.Printf("Username: %s (from form)\n", username)
    
    // FormValue can read from BOTH query params AND form data
    // It checks form data first, then query parameters
}
```

### Content-Type Matters

```go
// Different Content-Type headers affect how form data is encoded:

// 1. application/x-www-form-urlencoded (default for forms)
// Body: name=john&email=john%40example.com&age=25

// 2. multipart/form-data (used for file uploads)
// Body: 
// ------WebKitFormBoundary123
// Content-Disposition: form-data; name="name"
// 
// john
// ------WebKitFormBoundary123
// Content-Disposition: form-data; name="file"; filename="photo.jpg"
// Content-Type: image/jpeg
// 
// [binary file data]
// ------WebKitFormBoundary123--

func handleFormContentTypes(w http.ResponseWriter, r *http.Request) {
    contentType := r.Header.Get("Content-Type")
    
    if strings.Contains(contentType, "application/x-www-form-urlencoded") {
        // Standard form data
        r.ParseForm()
        name := r.FormValue("name")
        fmt.Printf("Standard form name: %s\n", name)
        
    } else if strings.Contains(contentType, "multipart/form-data") {
        // Multipart form (with potential file uploads)
        r.ParseMultipartForm(32 << 20) // 32MB limit
        name := r.FormValue("name")
        fmt.Printf("Multipart form name: %s\n", name)
        
        // Also handle file uploads
        file, header, err := r.FormFile("upload")
        if err == nil {
            defer file.Close()
            fmt.Printf("Uploaded file: %s\n", header.Filename)
        }
    }
}
```

---

## Parsing Query Parameters

### Basic Query Parameter Parsing

```go
func parseQueryBasics(w http.ResponseWriter, r *http.Request) {
    // Get all query parameters as a map
    queryParams := r.URL.Query()
    fmt.Printf("All params: %v\n", queryParams)
    
    // Get specific parameter (returns empty string if missing)
    search := r.URL.Query().Get("q")
    category := r.URL.Query().Get("category")
    
    // Check if parameter exists
    if search == "" {
        fmt.Fprintf(w, "No search query provided")
        return
    }
    
    fmt.Fprintf(w, "Searching for: %s in category: %s", search, category)
}
```

### Handling Multiple Values

```go
// URL: /search?tag=go&tag=web&tag=api
func parseMultipleValues(w http.ResponseWriter, r *http.Request) {
    // Get() only returns the first value
    firstTag := r.URL.Query().Get("tag")
    fmt.Printf("First tag: %s\n", firstTag) // "go"
    
    // Use slice access to get all values
    allTags := r.URL.Query()["tag"]
    fmt.Printf("All tags: %v\n", allTags) // [go web api]
    
    // Check if parameter was provided
    if tags, exists := r.URL.Query()["tag"]; exists {
        fmt.Fprintf(w, "Tags: %v", tags)
    } else {
        fmt.Fprintf(w, "No tags provided")
    }
}
```

### Converting Query Parameters

```go
func convertQueryParams(w http.ResponseWriter, r *http.Request) {
    // Remember: query parameters are ALWAYS strings
    
    // Convert to integer
    ageStr := r.URL.Query().Get("age")
    age, err := strconv.Atoi(ageStr)
    if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Invalid age: %s", ageStr)
        return
    }
    
    // Convert to boolean
    activeStr := r.URL.Query().Get("active")
    active, err := strconv.ParseBool(activeStr)
    if err != nil {
        // Default to false if not provided or invalid
        active = false
    }
    
    // Convert to float
    priceStr := r.URL.Query().Get("price")
    price, err := strconv.ParseFloat(priceStr, 64)
    if err != nil {
        price = 0.0
    }
    
    fmt.Fprintf(w, "Age: %d, Active: %t, Price: %.2f", age, active, price)
}
```

### Query Parameter Validation

```go
func validateQueryParams(w http.ResponseWriter, r *http.Request) {
    // Required parameter
    query := r.URL.Query().Get("q")
    if query == "" {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Query parameter 'q' is required")
        return
    }
    
    // Optional parameter with default
    limitStr := r.URL.Query().Get("limit")
    limit := 10 // default
    if limitStr != "" {
        if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
            limit = l
        }
    }
    
    // Enum validation
    sortBy := r.URL.Query().Get("sort")
    validSorts := map[string]bool{
        "name": true, "date": true, "popularity": true,
    }
    if sortBy != "" && !validSorts[sortBy] {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Invalid sort option: %s", sortBy)
        return
    }
    
    fmt.Fprintf(w, "Query: %s, Limit: %d, Sort: %s", query, limit, sortBy)
}
```

### Complete Query Parameter Example

```go
package main

import (
    "fmt"
    "net/http"
    "strconv"
    "strings"
)

// Search handler that processes various query parameters
func searchHandler(w http.ResponseWriter, r *http.Request) {
    // Parse and validate query parameters
    query := strings.TrimSpace(r.URL.Query().Get("q"))
    if query == "" {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Search query 'q' is required")
        return
    }
    
    // Optional parameters with defaults
    category := r.URL.Query().Get("category")
    if category == "" {
        category = "all"
    }
    
    // Convert numeric parameters
    page := 1
    if pageStr := r.URL.Query().Get("page"); pageStr != "" {
        if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
            page = p
        }
    }
    
    limit := 10
    if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
        if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 50 {
            limit = l
        }
    }
    
    // Boolean parameter
    includeDescription := false
    if desc := r.URL.Query().Get("include_desc"); desc == "true" || desc == "1" {
        includeDescription = true
    }
    
    // Multiple values
    tags := r.URL.Query()["tag"]
    
    // Build response
    w.Header().Set("Content-Type", "text/plain")
    fmt.Fprintf(w, "Search Results\n")
    fmt.Fprintf(w, "Query: %s\n", query)
    fmt.Fprintf(w, "Category: %s\n", category)
    fmt.Fprintf(w, "Page: %d\n", page)
    fmt.Fprintf(w, "Limit: %d\n", limit)
    fmt.Fprintf(w, "Include Description: %t\n", includeDescription)
    fmt.Fprintf(w, "Tags: %v\n", tags)
}

func main() {
    http.HandleFunc("/search", searchHandler)
    
    fmt.Println("Server starting on :8080")
    fmt.Println("Try: http://localhost:8080/search?q=golang&category=tutorial&page=2&limit=5&include_desc=true&tag=web&tag=api")
    
    http.ListenAndServe(":8080", nil)
}
```

---

## Parsing Form Data

### Basic Form Parsing

```go
func parseFormBasics(w http.ResponseWriter, r *http.Request) {
    // Must call ParseForm() before accessing form data
    err := r.ParseForm()
    if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Error parsing form: %v", err)
        return
    }
    
    // Now you can access form values
    username := r.FormValue("username")
    email := r.FormValue("email")
    
    fmt.Fprintf(w, "Username: %s, Email: %s", username, email)
}
```

### Understanding Form Parsing Methods

```go
func formParsingMethods(w http.ResponseWriter, r *http.Request) {
    // Method 1: r.FormValue() - convenient but limited
    // Automatically calls ParseForm() if needed
    // Reads from form data first, then query parameters
    username1 := r.FormValue("username")
    
    // Method 2: Manual parsing with more control
    err := r.ParseForm()
    if err != nil {
        http.Error(w, "Error parsing form", http.StatusBadRequest)
        return
    }
    
    // Access parsed form data
    username2 := r.Form.Get("username")        // Same as FormValue
    allUsernames := r.Form["username"]         // All values if multiple
    
    // Access only POST/PUT data (ignoring query params)
    usernamePostOnly := r.PostForm.Get("username")
    
    fmt.Printf("FormValue: %s\n", username1)
    fmt.Printf("Form.Get: %s\n", username2)
    fmt.Printf("All usernames: %v\n", allUsernames)
    fmt.Printf("POST only: %s\n", usernamePostOnly)
}
```

### Handling Different Form Types

```go
func handleFormTypes(w http.ResponseWriter, r *http.Request) {
    contentType := r.Header.Get("Content-Type")
    
    switch {
    case strings.Contains(contentType, "application/x-www-form-urlencoded"):
        // Standard form submission
        handleStandardForm(w, r)
        
    case strings.Contains(contentType, "multipart/form-data"):
        // Multipart form (usually with file uploads)
        handleMultipartForm(w, r)
        
    default:
        w.WriteHeader(http.StatusUnsupportedMediaType)
        fmt.Fprintf(w, "Unsupported content type: %s", contentType)
    }
}

func handleStandardForm(w http.ResponseWriter, r *http.Request) {
    // Parse standard form data
    err := r.ParseForm()
    if err != nil {
        http.Error(w, "Error parsing form", http.StatusBadRequest)
        return
    }
    
    name := r.FormValue("name")
    email := r.FormValue("email")
    age := r.FormValue("age")
    
    fmt.Fprintf(w, "Standard form - Name: %s, Email: %s, Age: %s", name, email, age)
}

func handleMultipartForm(w http.ResponseWriter, r *http.Request) {
    // Parse multipart form with size limit (32MB)
    err := r.ParseMultipartForm(32 << 20)
    if err != nil {
        http.Error(w, "Error parsing multipart form", http.StatusBadRequest)
        return
    }
    
    // Access form fields (same as standard form)
    name := r.FormValue("name")
    email := r.FormValue("email")
    
    // Access uploaded files
    file, header, err := r.FormFile("upload")
    if err == nil {
        defer file.Close()
        fmt.Printf("Uploaded file: %s, Size: %d bytes\n", header.Filename, header.Size)
    }
    
    fmt.Fprintf(w, "Multipart form - Name: %s, Email: %s", name, email)
}
```

### Form Validation Example

```go
type UserRegistration struct {
    Username string
    Email    string
    Age      int
    Terms    bool
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        fmt.Fprintf(w, "Only POST method allowed")
        return
    }
    
    // Parse form
    err := r.ParseForm()
    if err != nil {
        http.Error(w, "Error parsing form", http.StatusBadRequest)
        return
    }
    
    // Extract and validate data
    user, validationErrors := validateRegistrationForm(r)
    if len(validationErrors) > 0 {
        w.WriteHeader(http.StatusBadRequest)
        for _, err := range validationErrors {
            fmt.Fprintf(w, "Error: %s\n", err)
        }
        return
    }
    
    // Success
    fmt.Fprintf(w, "Registration successful for %s", user.Username)
}

func validateRegistrationForm(r *http.Request) (UserRegistration, []string) {
    var user UserRegistration
    var errors []string
    
    // Username validation
    user.Username = strings.TrimSpace(r.FormValue("username"))
    if user.Username == "" {
        errors = append(errors, "Username is required")
    } else if len(user.Username) < 3 {
        errors = append(errors, "Username must be at least 3 characters")
    }
    
    // Email validation
    user.Email = strings.TrimSpace(r.FormValue("email"))
    if user.Email == "" {
        errors = append(errors, "Email is required")
    } else if !strings.Contains(user.Email, "@") {
        errors = append(errors, "Invalid email format")
    }
    
    // Age validation
    ageStr := r.FormValue("age")
    if ageStr == "" {
        errors = append(errors, "Age is required")
    } else {
        age, err := strconv.Atoi(ageStr)
        if err != nil {
            errors = append(errors, "Age must be a number")
        } else if age < 13 || age > 120 {
            errors = append(errors, "Age must be between 13 and 120")
        } else {
            user.Age = age
        }
    }
    
    // Terms validation
    terms := r.FormValue("terms")
    user.Terms = terms == "on" || terms == "true" || terms == "1"
    if !user.Terms {
        errors = append(errors, "You must accept the terms and conditions")
    }
    
    return user, errors
}
```

---

## Reading Request Body

### Understanding Request Body

The request body contains raw data sent by the client. Unlike form data, you need to read and parse it manually.

```go
func readBodyBasics(w http.ResponseWriter, r *http.Request) {
    // Read the entire body
    body, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Error reading body", http.StatusBadRequest)
        return
    }
    defer r.Body.Close() // Always close the body
    
    fmt.Printf("Body content: %s\n", string(body))
    fmt.Printf("Body length: %d bytes\n", len(body))
    
    // Note: Body can only be read once!
    // After this, r.Body is empty
}
```

### JSON Request Body

```go
type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

func handleJSONRequest(w http.ResponseWriter, r *http.Request) {
    // Check content type
    if r.Header.Get("Content-Type") != "application/json" {
        w.WriteHeader(http.StatusUnsupportedMediaType)
        fmt.Fprintf(w, "Expected application/json")
        return
    }
    
    // Decode JSON directly from request body
    var user User
    err := json.NewDecoder(r.Body).Decode(&user)
    if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Invalid JSON: %v", err)
        return
    }
    defer r.Body.Close()
    
    // Validate the decoded data
    if user.Name == "" || user.Email == "" {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprintf(w, "Name and email are required")
        return
    }
    
    // Process the user data
    fmt.Printf("Received user: %+v\n", user)
    
    // Send JSON response
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "message": fmt.Sprintf("User %s created successfully", user.Name),
        "user":    user,
    })
}
```

### Handling Large Bodies

```go
func handleLargeBody(w http.ResponseWriter, r *http.Request) {
    // Limit body size to prevent abuse (10MB)
    maxSize := int64(10 << 20) // 10MB
    r.Body = http.MaxBytesReader(w, r.Body, maxSize)
    
    // Stream processing for large bodies
    buffer := make([]byte, 1024) // 1KB chunks
    totalSize := 0
    
    for {
        n, err := r.Body.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            http.Error(w, "Error reading body", http.StatusBadRequest)
            return
        }
        
        totalSize += n
        
        // Process chunk
        fmt.Printf("Read %d bytes (total: %d)\n", n, totalSize)
    }
    
    fmt.Fprintf(w, "Processed %d bytes total", totalSize)
}
```

### Body vs Form Data Decision Tree

```go
func handleRequestData(w http.ResponseWriter, r *http.Request) {
    contentType := r.Header.Get("Content-Type")
    
    switch {
    case contentType == "application/json":
        handleJSONBody(w, r)
        
    case strings.Contains(contentType, "application/x-www-form-urlencoded"):
        handleFormData(w, r)
        
    case strings.Contains(contentType, "multipart/form-data"):
        handleMultipartForm(w, r)
        
    case contentType == "text/plain":
        handleTextBody(w, r)
        
    default:
        // Try to handle as form data (default browser behavior)
        if r.Method == "POST" || r.Method == "PUT" {
            handleFormData(w, r)
        } else {
            fmt.Fprintf(w, "Unsupported content type: %s", contentType)
        }
    }
}

func handleJSONBody(w http.ResponseWriter, r *http.Request) {
    var data map[string]interface{}
    json.NewDecoder(r.Body).Decode(&data)
    fmt.Fprintf(w, "JSON data: %v", data)
}

func handleTextBody(w http.ResponseWriter, r *http.Request) {
    body, _ := io.ReadAll(r.Body)
    fmt.Fprintf(w, "Text body: %s", string(body))
}
```

---

## Complete Request Data Examples

### Example 1: Search API with Multiple Data Sources

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strconv"
    "strings"
)

type SearchRequest struct {
    Query      string   `json:"query"`
    Categories []string `json:"categories"`
    Filters    map[string]interface{} `json:"filters"`
}

type SearchResponse struct {
    Query   string      `json:"query"`
    Results []SearchResult `json:"results"`
    Total   int         `json:"total"`
    Page    int         `json:"page"`
    Limit   int         `json:"limit"`
}

type SearchResult struct {
    ID          int    `json:"id"`
    Title       string `json:"title"`
    Description string `json:"description"`
    Category    string `json:"category"`
}

func searchAPIHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    var searchReq SearchRequest
    var query string
    var categories []string
    
    // Handle different request methods and data sources
    switch r.Method {
    case http.MethodGet:
        // GET request - data from query parameters
        query = r.URL.Query().Get("q")
        if catStr := r.URL.Query().Get("categories"); catStr != "" {
            categories = strings.Split(catStr, ",")
        }
        
        searchReq = SearchRequest{
            Query:      query,
            Categories: categories,
        }
        
    case http.MethodPost:
        // POST request - data from JSON body
        if err := json.NewDecoder(r.Body).Decode(&searchReq); err != nil {
            w.WriteHeader(http.StatusBadRequest)
            json.NewEncoder(w).Encode(map[string]string{
                "error": "Invalid JSON body",
            })
            return
        }
        defer r.Body.Close()
        
    default:
        w.WriteHeader(http.StatusMethodNotAllowed)
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Only GET and POST methods allowed",
        })
        return
    }
    
    // Validate search request
    if searchReq.Query == "" {
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Query parameter 'q' or 'query' is required",
        })
        return
    }
    
    // Parse pagination parameters (from query string for both GET and POST)
    page := 1
    if pageStr := r.URL.Query().Get("page"); pageStr != "" {
        if p, err := strconv.Atoi(pageStr); err == nil && p > 0 {
            page = p
        }
    }
    
    limit := 10
    if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
        if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
            limit = l
        }
    }
    
    // Simulate search results
    mockResults := []SearchResult{
        {ID: 1, Title: "Go Programming Tutorial", Description: "Learn Go basics", Category: "tutorial"},
        {ID: 2, Title: "Advanced Go Patterns", Description: "Advanced Go techniques", Category: "advanced"},
        {ID: 3, Title: "Go Web Development", Description: "Building web apps with Go", Category: "web"},
    }
    
    // Filter results based on categories
    var filteredResults []SearchResult
    if len(searchReq.Categories) == 0 {
        filteredResults = mockResults
    } else {
        for _, result := range mockResults {
            for _, cat := range searchReq.Categories {
                if result.Category == cat {
                    filteredResults = append(filteredResults, result)
                    break
                }
            }
        }
    }
    
    // Apply pagination
    start := (page - 1) * limit
    end := start + limit
    if start >= len(filteredResults) {
        filteredResults = []SearchResult{}
    } else if end > len(filteredResults) {
        filteredResults = filteredResults[start:]
    } else {
        filteredResults = filteredResults[start:end]
    }
    
    // Build response
    response := SearchResponse{
        Query:   searchReq.Query,
        Results: filteredResults,
        Total:   len(mockResults),
        Page:    page,
        Limit:   limit,
    }
    
    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/api/search", searchAPIHandler)
    
    fmt.Println("Search API server starting on :8080")
    fmt.Println("\nTry these requests:")
    fmt.Println("GET  http://localhost:8080/api/search?q=go&categories=tutorial,web&page=1&limit=5")
    fmt.Println("POST http://localhost:8080/api/search")
    fmt.Println("     Body: {\"query\": \"go\", \"categories\": [\"tutorial\"], \"filters\": {}}")
    
    http.ListenAndServe(":8080", nil)
}
```

### Example 2: User Registration with File Upload

```go
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "os"
    "path/filepath"
    "strconv"
    "strings"
    "time"
)

type UserProfile struct {
    Username    string `json:"username"`
    Email       string `json:"email"`
    Age         int    `json:"age"`
    Bio         string `json:"bio"`
    Avatar      string `json:"avatar,omitempty"`
    Preferences map[string]string `json:"preferences"`
}

func userRegistrationHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        w.WriteHeader(http.StatusMethodNotAllowed)
        fmt.Fprintf(w, "Only POST method allowed")
        return
    }
    
    // Check content type to determine parsing strategy
    contentType := r.Header.Get("Content-Type")
    
    if strings.Contains(contentType, "multipart/form-data") {
        handleMultipartRegistration(w, r)
    } else if strings.Contains(contentType, "application/x-www-form-urlencoded") {
        handleFormRegistration(w, r)
    } else if strings.Contains(contentType, "application/json") {
        handleJSONRegistration(w, r)
    } else {
        w.WriteHeader(http.StatusUnsupportedMediaType)
        fmt.Fprintf(w, "Unsupported content type: %s", contentType)
    }
}

func handleMultipartRegistration(w http.ResponseWriter, r *http.Request) {
    // Parse multipart form (32MB limit)
    err := r.ParseMultipartForm(32 << 20)
    if err != nil {
        http.Error(w, "Error parsing multipart form", http.StatusBadRequest)
        return
    }
    
    // Extract form fields
    profile := UserProfile{
        Username: r.FormValue("username"),
        Email:    r.FormValue("email"),
        Bio:      r.FormValue("bio"),
        Preferences: make(map[string]string),
    }
    
    // Parse age
    if ageStr := r.FormValue("age"); ageStr != "" {
        age, err := strconv.Atoi(ageStr)
        if err == nil {
            profile.Age = age
        }
    }
    
    // Parse preferences (comma-separated key:value pairs)
    if prefStr := r.FormValue("preferences"); prefStr != "" {
        pairs := strings.Split(prefStr, ",")
        for _, pair := range pairs {
            if kv := strings.Split(pair, ":"); len(kv) == 2 {
                profile.Preferences[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
            }
        }
    }
    
    // Handle file upload
    file, header, err := r.FormFile("avatar")
    if err == nil {
        defer file.Close()
        
        // Save uploaded file
        avatarPath := fmt.Sprintf("uploads/avatars/%s_%s", 
            profile.Username, header.Filename)
        
        os.MkdirAll(filepath.Dir(avatarPath), 0755)
        
        dst, err := os.Create(avatarPath)
        if err == nil {
            defer dst.Close()
            io.Copy(dst, file)
            profile.Avatar = avatarPath
        }
    }
    
    // Validate and respond
    if errors := validateProfile(profile); len(errors) > 0 {
        w.WriteHeader(http.StatusBadRequest)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "success": false,
            "errors":  errors,
        })
        return
    }
    
    // Success response
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "message": "User registered successfully",
        "profile": profile,
    })
}

func handleFormRegistration(w http.ResponseWriter, r *http.Request) {
    err := r.ParseForm()
    if err != nil {
        http.Error(w, "Error parsing form", http.StatusBadRequest)
        return
    }
    
    // Similar to multipart but without file upload support
    profile := UserProfile{
        Username: r.FormValue("username"),
        Email:    r.FormValue("email"),
        Bio:      r.FormValue("bio"),
        Preferences: make(map[string]string),
    }
    
    if ageStr := r.FormValue("age"); ageStr != "" {
        age, err := strconv.Atoi(ageStr)
        if err == nil {
            profile.Age = age
        }
    }
    
    respondWithProfile(w, profile)
}

func handleJSONRegistration(w http.ResponseWriter, r *http.Request) {
    var profile UserProfile
    
    err := json.NewDecoder(r.Body).Decode(&profile)
    if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]string{
            "error": "Invalid JSON format",
        })
        return
    }
    defer r.Body.Close()
    
    respondWithProfile(w, profile)
}

func validateProfile(profile UserProfile) []string {
    var errors []string
    
    if profile.Username == "" {
        errors = append(errors, "Username is required")
    } else if len(profile.Username) < 3 {
        errors = append(errors, "Username must be at least 3 characters")
    }
    
    if profile.Email == "" {
        errors = append(errors, "Email is required")
    } else if !strings.Contains(profile.Email, "@") {
        errors = append(errors, "Invalid email format")
    }
    
    if profile.Age < 13 || profile.Age > 120 {
        errors = append(errors, "Age must be between 13 and 120")
    }
    
    return errors
}

func respondWithProfile(w http.ResponseWriter, profile UserProfile) {
    if errors := validateProfile(profile); len(errors) > 0 {
        w.WriteHeader(http.StatusBadRequest)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "success": false,
            "errors":  errors,
        })
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "message": "Profile processed successfully",
        "profile": profile,
    })
}

func registrationFormHandler(w http.ResponseWriter, r *http.Request) {
    html := `
    <!DOCTYPE html>
    <html>
    <head><title>User Registration</title></head>
    <body>
        <h2>User Registration</h2>
        
        <h3>Multipart Form (with file upload)</h3>
        <form action="/register" method="post" enctype="multipart/form-data">
            <input type="text" name="username" placeholder="Username" required><br>
            <input type="email" name="email" placeholder="Email" required><br>
            <input type="number" name="age" placeholder="Age" min="13" max="120"><br>
            <textarea name="bio" placeholder="Bio"></textarea><br>
            <input type="text" name="preferences" placeholder="theme:dark,lang:en"><br>
            <input type="file" name="avatar" accept="image/*"><br>
            <button type="submit">Register (Multipart)</button>
        </form>
        
        <h3>URL-encoded Form</h3>
        <form action="/register" method="post">
            <input type="text" name="username" placeholder="Username" required><br>
            <input type="email" name="email" placeholder="Email" required><br>
            <input type="number" name="age" placeholder="Age" min="13" max="120"><br>
            <textarea name="bio" placeholder="Bio"></textarea><br>
            <button type="submit">Register (Form)</button>
        </form>
        
        <h3>JSON API Example</h3>
        <pre>
POST /register
Content-Type: application/json

{
    "username": "johndoe",
    "email": "john@example.com",
    "age": 25,
    "bio": "Software developer",
    "preferences": {
        "theme": "dark",
        "language": "en"
    }
}
        </pre>
    </body>
    </html>
    `
    
    w.Header().Set("Content-Type", "text/html")
    fmt.Fprintf(w, html)
}

func main() {
    http.HandleFunc("/", registrationFormHandler)
    http.HandleFunc("/register", userRegistrationHandler)
    
    fmt.Println("User registration server starting on :8080")
    fmt.Println("Visit: http://localhost:8080")
    
    http.ListenAndServe(":8080", nil)
}
```

---

## Data Validation and Error Handling

### Input Validation Patterns

```go
type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
    Value   string `json:"value,omitempty"`
}

func validateEmail(email string) *ValidationError {
    if email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "Email is required",
        }
    }
    
    if !strings.Contains(email, "@") || !strings.Contains(email, ".") {
        return &ValidationError{
            Field:   "email",
            Message: "Invalid email format",
            Value:   email,
        }
    }
    
    return nil
}

func validateAge(ageStr string) (int, *ValidationError) {
    if ageStr == "" {
        return 0, &ValidationError{
            Field:   "age",
            Message: "Age is required",
        }
    }
    
    age, err := strconv.Atoi(ageStr)
    if err != nil {
        return 0, &ValidationError{
            Field:   "age",
            Message: "Age must be a number",
            Value:   ageStr,
        }
    }
    
    if age < 0 || age > 150 {
        return 0, &ValidationError{
            Field:   "age",
            Message: "Age must be between 0 and 150",
            Value:   ageStr,
        }
    }
    
    return age, nil
}

func validatedHandler(w http.ResponseWriter, r *http.Request) {
    var errors []*ValidationError
    
    // Validate email
    email := r.FormValue("email")
    if err := validateEmail(email); err != nil {
        errors = append(errors, err)
    }
    
    // Validate age
    ageStr := r.FormValue("age")
    age, err := validateAge(ageStr)
    if err != nil {
        errors = append(errors, err)
    }
    
    // If there are validation errors, return them
    if len(errors) > 0 {
        w.WriteHeader(http.StatusBadRequest)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
            "success": false,
            "errors":  errors,
        })
        return
    }
    
    // Process valid data
    fmt.Fprintf(w, "Valid data - Email: %s, Age: %d", email, age)
}
```

### Error Response Patterns

```go
func sendErrorResponse(w http.ResponseWriter, statusCode int, message string, details interface{}) {
    w.WriteHeader(statusCode)
    w.Header().Set("Content-Type", "application/json")
    
    response := map[string]interface{}{
        "success": false,
        "error":   message,
        "timestamp": time.Now().Format(time.RFC3339),
    }
    
    if details != nil {
        response["details"] = details
    }
    
    json.NewEncoder(w).Encode(response)
}

func robustHandler(w http.ResponseWriter, r *http.Request) {
    // Content type validation
    if r.Header.Get("Content-Type") != "application/json" {
        sendErrorResponse(w, http.StatusUnsupportedMediaType, 
            "Content-Type must be application/json", nil)
        return
    }
    
    // Body size validation
    if r.ContentLength > 1024*1024 { // 1MB limit
        sendErrorResponse(w, http.StatusRequestEntityTooLarge,
            "Request body too large", map[string]interface{}{
                "max_size": "1MB",
                "received": r.ContentLength,
            })
        return
    }
    
    // Parse JSON with error handling
    var data map[string]interface{}
    decoder := json.NewDecoder(r.Body)
    decoder.DisallowUnknownFields() // Strict parsing
    
    if err := decoder.Decode(&data); err != nil {
        sendErrorResponse(w, http.StatusBadRequest,
            "Invalid JSON format", map[string]string{
                "parse_error": err.Error(),
            })
        return
    }
    
    // Success response
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "success": true,
        "message": "Data processed successfully",
        "data":    data,
    })
}
```

## Key Takeaways

### Request Data Fundamentals
1. **Query Parameters** - In the URL after `?`, always strings, good for filtering/pagination
2. **Form Data** - In request body, requires parsing, good for user input
3. **JSON Body** - In request body, structured data, good for APIs
4. **Multipart Data** - In request body, supports files, good for uploads

### Parsing Methods
1. **r.URL.Query()** - Parse query parameters from URL
2. **r.FormValue()** - Parse form data (automatically calls ParseForm)
3. **r.ParseForm()** - Manual form parsing with more control
4. **json.NewDecoder(r.Body)** - Parse JSON from request body

### Best Practices
1. **Always validate input** - Never trust client data
2. **Handle parsing errors** - Forms and JSON can be malformed
3. **Set size limits** - Prevent abuse with large requests
4. **Close request bodies** - Use `defer r.Body.Close()`
5. **Return helpful error messages** - Guide users to correct input

### Common Patterns
- **Method-based routing** - Handle different data types based on HTTP method
- **Content-Type detection** - Parse data differently based on Content-Type header
- **Validation chains** - Validate each field systematically
- **Error aggregation** - Collect all validation errors before responding

Understanding request data parsing is essential for building robust web APIs that can handle various input formats and provide meaningful feedback to clients.
